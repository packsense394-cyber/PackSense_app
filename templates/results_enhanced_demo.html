<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PackSense - Detailed Analysis</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 25%, #2d2d2d 50%, #404040 75%, #555555 100%);
            min-height: 100vh;
            color: #ffffff;
            overflow-x: hidden;
        }
        
        /* Animated background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(255, 255, 255, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 255, 255, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(255, 255, 255, 0.04) 0%, transparent 50%);
            z-index: -1;
            animation: float 20s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            33% { transform: translateY(-20px) rotate(1deg); }
            66% { transform: translateY(10px) rotate(-1deg); }
        }
        
        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 40px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
        }
        
        .logo {
            display: flex;
            align-items: center;
            font-size: 1.8em;
            font-weight: 700;
        }
        
        .logo-icon {
            color: #ffffff;
            margin-right: 10px;
        }
        
        .nav-links {
            display: flex;
            gap: 20px;
        }
        
        .nav-link {
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            border-radius: 25px;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .nav-link:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        
        /* Slider styling for co-occurrence filters */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
        }
        
        input[type="range"]::-webkit-slider-track {
            background: #ddd;
            height: 6px;
            border-radius: 3px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            background: #667eea;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #5a6fd8;
            transform: scale(1.1);
        }
        
        input[type="range"]::-moz-range-track {
            background: #ddd;
            height: 6px;
            border-radius: 3px;
        }
        
        input[type="range"]::-moz-range-thumb {
            background: #667eea;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            cursor: pointer;
        }
        
        /* Main layout with sidebar */
        .main-layout {
            display: flex;
            margin-top: 80px;
            min-height: calc(100vh - 80px);
        }
        
        /* Sidebar */
        .sidebar {
            width: 350px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            padding: 30px;
            overflow-y: auto;
            position: fixed;
            left: 0;
            top: 80px;
            height: calc(100vh - 80px);
            z-index: 999;
        }
        
        /* Main content area */
        .main-content {
            flex: 1;
            margin-left: 350px;
            padding: 30px;
            overflow-y: auto;
        }
        
        /* Sidebar sections */
        .sidebar-section {
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .sidebar-section h3 {
            color: #ffffff;
            font-size: 1.2em;
            margin-bottom: 15px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        /* Review filters */
        .review-filter {
            display: block;
            width: 100%;
            padding: 12px 15px;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #333333 0%, #555555 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
            font-weight: 500;
        }
        
        .review-filter:hover {
            transform: translateX(5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .review-filter.active {
            background: linear-gradient(135deg, #666666 0%, #888888 100%);
            box-shadow: 0 5px 15px rgba(255, 255, 255, 0.1);
        }
        
        .filter-count {
            float: right;
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
        }
        
        /* Filter controls */
        .filter-control {
            margin-bottom: 15px;
        }
        
        .filter-control label {
            display: block;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 8px;
            font-size: 0.9em;
        }
        
        .filter-control select,
        .filter-control input {
            width: 100%;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            font-size: 0.9em;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
        }
        
        /* Action buttons */
        .action-btn {
            display: block;
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            text-decoration: none;
            text-align: center;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-warning {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }
        
        .btn-success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }
        
        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        /* Metrics cards */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .metric-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }
        
        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.15);
        }
        
        .metric-icon {
            font-size: 2.5em;
            margin-bottom: 15px;
            display: block;
        }
        
        .metric-value {
            font-size: 2em;
            font-weight: 700;
            color: #1e3c72;
            margin-bottom: 8px;
        }
        
        .metric-label {
            font-size: 1em;
            color: #666;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Word Cloud Styles - Futuristic Design with Multi-Color Palette */
        .word-cloud-container {
            background: radial-gradient(ellipse at center, 
                #0a0a0a 0%, 
                #1a1a1a 25%, 
                #2d2d2d 50%, 
                #404040 75%, 
                #555555 100%);
            color: white;
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 30px;
            text-align: center;
            min-height: 400px;
            position: relative;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
        }

        .word-cloud-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 80%, rgba(100, 200, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(50, 150, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(0, 255, 255, 0.1) 0%, transparent 50%),
                linear-gradient(45deg, transparent 30%, rgba(255,255,255,0.05) 50%, transparent 70%);
            animation: shimmer 4s ease-in-out infinite;
            pointer-events: none;
        }

        .word-cloud-container::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 60% 60%, rgba(50, 205, 50, 0.05) 0%, transparent 40%),
                radial-gradient(circle at 30% 70%, rgba(255, 99, 71, 0.05) 0%, transparent 40%);
            animation: float 6s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes shimmer {
            0%, 100% { transform: translateX(-100%) rotate(0deg); }
            50% { transform: translateX(100%) rotate(180deg); }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) scale(1); }
            33% { transform: translateY(-10px) scale(1.05); }
            66% { transform: translateY(10px) scale(0.95); }
        }

        .word-cloud-container h3 {
            margin-bottom: 10px;
            font-size: 1.5em;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #ffffff;
            text-shadow: 0 0 20px rgba(255,255,255,0.5);
            font-family: 'Orbitron', 'Rajdhani', monospace;
            position: relative;
            z-index: 2;
        }

        .word-cloud-container h3 i {
            margin-right: 10px;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .word-cloud-container p {
            color: #e8f4fd;
            font-size: 0.9em;
            margin-bottom: 20px;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 400;
            position: relative;
            z-index: 2;
        }

        .word-tooltip {
            position: absolute;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #ffffff;
            padding: 12px 16px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            pointer-events: none;
            z-index: 1000;
            white-space: nowrap;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform: translateX(-50%) scale(0.8);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 255, 0.3);
            font-family: 'Rajdhani', sans-serif;
            backdrop-filter: blur(10px);
        }

        .word-tooltip.show {
            opacity: 1;
            transform: translateX(-50%) scale(1);
        }

        .word-tooltip::after {
            content: '';
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            border: 8px solid transparent;
        }
        
        /* Default arrow pointing down (above word) */
        .word-tooltip::after {
            top: 100%;
            border-top-color: #1a1a2e;
        }
        
        /* Arrow pointing up (below word) */
        .word-tooltip.arrow-up::after {
            bottom: 100%;
            border-bottom-color: #1a1a2e;
            border-top-color: transparent;
        }

        .word-cloud {
            width: 100%;
            height: 320px;
            position: relative;
            overflow: hidden;
            border-radius: 15px;
            background: rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }

        .word-cloud-word {
            position: absolute;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            font-weight: 600;
            text-shadow: 0 0 10px currentColor;
            user-select: none;
            font-family: 'Orbitron', 'Rajdhani', monospace;
            border-radius: 8px;
            padding: 6px 12px;
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
            white-space: nowrap;
            min-width: fit-content;
            text-align: center;
            box-sizing: border-box;
        }

        .word-cloud-word:hover {
            transform: scale(1.3) rotate(2deg);
            z-index: 100;
            box-shadow: 0 0 30px currentColor, 0 0 60px rgba(255,255,255,0.3);
            background: rgba(255,255,255,0.15) !important;
            border-color: currentColor !important;
            animation: wordPulse 0.6s ease-in-out;
        }

        @keyframes wordPulse {
            0% { transform: scale(1.3) rotate(2deg); }
            50% { transform: scale(1.4) rotate(3deg); }
            100% { transform: scale(1.3) rotate(2deg); }
        }

        .word-tooltip {
            position: absolute;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #ffffff;
            padding: 12px 16px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            pointer-events: none;
            z-index: 1000;
            white-space: nowrap;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform: translateX(-50%) scale(0.8);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 255, 0.3);
            font-family: 'Rajdhani', sans-serif;
            backdrop-filter: blur(10px);
        }

        .word-tooltip.show {
            opacity: 1;
            transform: translateX(-50%) scale(1);
        }

        .word-tooltip::after {
            content: '';
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            border: 8px solid transparent;
        }
        
        /* Default arrow pointing down (above word) */
        .word-tooltip::after {
            top: 100%;
            border-top-color: #1a1a2e;
        }
        
        /* Arrow pointing up (below word) */
        .word-tooltip.arrow-up::after {
            bottom: 100%;
            border-bottom-color: #1a1a2e;
            border-top-color: transparent;
        }

        /* Frequency-based color classes - Bright & Vibrant for Blue Background */
        
        /* LOW FREQUENCY - Bright Cool Colors */
        .word-freq-low-cyan {
            color: #00ffff !important;
            text-shadow: 0 0 20px #00ffff, 0 0 30px #00ffff !important;
            background: rgba(0, 255, 255, 0.2) !important;
            border-color: rgba(0, 255, 255, 0.5) !important;
        }

        .word-freq-low-blue {
            color: #87ceeb !important;
            text-shadow: 0 0 20px #87ceeb, 0 0 30px #87ceeb !important;
            background: rgba(135, 206, 235, 0.2) !important;
            border-color: rgba(135, 206, 235, 0.5) !important;
        }

        .word-freq-low-purple {
            color: #da70d6 !important;
            text-shadow: 0 0 20px #da70d6, 0 0 30px #da70d6 !important;
            background: rgba(218, 112, 214, 0.2) !important;
            border-color: rgba(218, 112, 214, 0.5) !important;
        }

        /* MEDIUM FREQUENCY - Bright Green/Teal Spectrum */
        .word-freq-medium-green {
            color: #00ff00 !important;
            text-shadow: 0 0 20px #00ff00, 0 0 30px #00ff00 !important;
            background: rgba(0, 255, 0, 0.2) !important;
            border-color: rgba(0, 255, 0, 0.5) !important;
        }

        .word-freq-medium-blue {
            color: #00bfff !important;
            text-shadow: 0 0 20px #00bfff, 0 0 30px #00bfff !important;
            background: rgba(0, 191, 255, 0.2) !important;
            border-color: rgba(0, 191, 255, 0.5) !important;
        }

        .word-freq-medium-teal {
            color: #40e0d0 !important;
            text-shadow: 0 0 20px #40e0d0, 0 0 30px #40e0d0 !important;
            background: rgba(64, 224, 208, 0.2) !important;
            border-color: rgba(64, 224, 208, 0.5) !important;
        }

        /* HIGH FREQUENCY - Bright Orange/Yellow Spectrum */
        .word-freq-high-orange {
            color: #ff8c00 !important;
            text-shadow: 0 0 25px #ff8c00, 0 0 35px #ff8c00 !important;
            background: rgba(255, 140, 0, 0.2) !important;
            border-color: rgba(255, 140, 0, 0.5) !important;
        }

        .word-freq-high-yellow {
            color: #ffff00 !important;
            text-shadow: 0 0 25px #ffff00, 0 0 35px #ffff00 !important;
            background: rgba(255, 255, 0, 0.2) !important;
            border-color: rgba(255, 255, 0, 0.5) !important;
        }

        .word-freq-high-amber {
            color: #ffcc00 !important;
            text-shadow: 0 0 25px #ffcc00, 0 0 35px #ffcc00 !important;
            background: rgba(255, 204, 0, 0.2) !important;
            border-color: rgba(255, 204, 0, 0.5) !important;
        }

        /* VERY HIGH FREQUENCY - Bright Warm Colors */
        .word-freq-very-high-red {
            color: #ff4444 !important;
            text-shadow: 0 0 30px #ff4444, 0 0 40px #ff4444 !important;
            background: rgba(255, 68, 68, 0.2) !important;
            border-color: rgba(255, 68, 68, 0.5) !important;
        }

        .word-freq-very-high-orange {
            color: #ff6600 !important;
            text-shadow: 0 0 30px #ff6600, 0 0 40px #ff6600 !important;
            background: rgba(255, 102, 0, 0.2) !important;
            border-color: rgba(255, 102, 0, 0.5) !important;
        }

        .word-freq-very-high-coral {
            color: #ff6b6b !important;
            text-shadow: 0 0 30px #ff6b6b, 0 0 40px #ff6b6b !important;
            background: rgba(255, 107, 107, 0.2) !important;
            border-color: rgba(255, 107, 107, 0.5) !important;
        }

        /* EXTREME FREQUENCY - Brightest Hot Colors */
        .word-freq-extreme-pink {
            color: #ff00ff !important;
            text-shadow: 0 0 35px #ff00ff, 0 0 45px #ff00ff !important;
            background: rgba(255, 0, 255, 0.2) !important;
            border-color: rgba(255, 0, 255, 0.5) !important;
        }

        .word-freq-extreme-red {
            color: #ff0000 !important;
            text-shadow: 0 0 35px #ff0000, 0 0 45px #ff0000 !important;
            background: rgba(255, 0, 0, 0.2) !important;
            border-color: rgba(255, 0, 0, 0.5) !important;
        }

        .word-freq-extreme-purple {
            color: #cc00cc !important;
            text-shadow: 0 0 35px #cc00cc, 0 0 45px #cc00cc !important;
            background: rgba(204, 0, 204, 0.2) !important;
            border-color: rgba(204, 0, 204, 0.5) !important;
        }
        
        /* Reviews section */
        .reviews-section {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        }
        
        .reviews-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .reviews-title {
            font-size: 1.5em;
            font-weight: 600;
            color: #ffffff;
        }
        
        .reviews-count {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9em;
        }
        
        /* Review cards */
        .review-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            border-left: 4px solid rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }
        
        .review-card:hover {
            transform: translateX(5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.12);
        }
        
        .review-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .reviewer-info {
            flex: 1;
            min-width: 200px;
        }
        
        .reviewer-name {
            font-weight: 600;
            color: #ffffff;
            font-size: 1.1em;
            margin-bottom: 5px;
        }
        
        .review-title {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9em;
            font-style: italic;
            margin-bottom: 5px;
        }
        
        .review-rating {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .stars {
            color: #ffd700;
        }
        
        .review-date {
            color: #666;
            font-size: 0.9em;
        }
        
        .review-text {
            line-height: 1.6;
            color: #ffffff;
            margin-bottom: 15px;
        }
        
        .review-images {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .review-image {
            width: 80px;
            height: 80px;
            object-fit: cover;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.3s ease;
        }
        
        .review-image:hover {
            transform: scale(1.1);
        }
        
        .packaging-badge {
            display: inline-block;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: 600;
            margin-top: 10px;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
                position: relative;
                height: auto;
            }
            
            .main-content {
                margin-left: 0;
            }
            
            .main-layout {
                flex-direction: column;
            }
        }
        
        /* Loading animation */
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Chatbot styles */
        .chatbot-container {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 1000;
        }
        
        .chatbot-toggle {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            cursor: pointer;
            font-size: 24px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }
        
        .chatbot-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        .chatbot-modal {
            position: fixed;
            bottom: 100px;
            right: 30px;
            width: 400px;
            height: 500px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: none;
            flex-direction: column;
            overflow: hidden;
        }
        
        .chatbot-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .chatbot-header h3 {
            margin: 0;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .chatbot-close {
            background: none;
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
            padding: 5px;
        }
        
        .chatbot-messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #f8f9fa;
        }
        
        .message {
            margin-bottom: 15px;
            display: flex;
        }
        
        .user-message {
            justify-content: flex-end;
        }
        
        .bot-message {
            justify-content: flex-start;
        }
        
        .message-content {
            max-width: 80%;
            padding: 12px 16px;
            border-radius: 18px;
            font-size: 0.9em;
            line-height: 1.4;
        }
        
        .user-message .message-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .bot-message .message-content {
            background: white;
            color: #333;
            border: 1px solid #e0e0e0;
        }
        
        .chatbot-input {
            padding: 15px 20px;
            background: white;
            border-top: 1px solid #e0e0e0;
            display: flex;
            gap: 10px;
        }
        
        .chatbot-input input {
            flex: 1;
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 20px;
            font-size: 0.9em;
        }
        
        .chatbot-input button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .chatbot-input button:hover {
            transform: scale(1.05);
        }
        
        /* Pagination styles */
        .pagination-container {
            margin-top: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        .pagination-info {
            text-align: center;
            margin-bottom: 15px;
            color: #1e3c72;
            font-weight: 600;
        }
        
        .pagination-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
        }
        
        .pagination-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .pagination-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .pagination-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .page-numbers {
            display: flex;
            gap: 5px;
        }
        
        .page-number {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        
        .page-number:hover {
            background: #667eea;
            color: white;
        }
        
        .page-number.active {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border-color: #4facfe;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="logo">
            <i class="fas fa-box logo-icon"></i>
            PackSense
        </div>
        <div class="nav-links">
            <a href="/" class="nav-link">Home</a>
            <a href="/" class="nav-link">+ New Analysis</a>
        </div>
    </div>

    <!-- Demo Mode Indicator -->
    {% if is_demo %}
    <div style="
        background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        color: white;
        text-align: center;
        padding: 12px 20px;
        font-weight: 600;
        box-shadow: 0 2px 10px rgba(40, 167, 69, 0.3);
        position: relative;
        z-index: 1000;
    ">
        <i class="fas fa-play-circle"></i> 
        DEMO MODE - Showing sample data from Tide Ultra Oxi Boost Laundry Detergent
        <span style="font-size: 0.9em; opacity: 0.9; margin-left: 10px;">
            (No scraping required - all features functional)
        </span>
    </div>
    {% endif %}

    <!-- Main Layout -->
    <div class="main-layout">
        <!-- Sidebar -->
        <div class="sidebar">
            <!-- Product Info -->
            <div class="sidebar-section">
                <h3><i class="fas fa-box"></i> Product Info</h3>
                <p><strong>{{ product_name }}</strong></p>
                <a href="{{ product_description_url }}" class="action-btn btn-success">
                    <i class="fas fa-info-circle"></i> View Product Page
                </a>
            </div>

            <!-- Review Filters -->
            <div class="sidebar-section">
                <h3><i class="fas fa-filter"></i> Review Filters</h3>
                <button class="review-filter active" data-filter="all" id="filter-all">
                    All Reviews <span class="filter-count" id="count-all">{{ kpi.total|default(review_filters.all_reviews) }}</span>
                </button>
                <button class="review-filter" data-filter="packaging" id="filter-pack">
                    Packaging Related <span class="filter-count" id="count-pack">{{ kpi.packaging_related|default(review_filters.packaging_reviews) }}</span>
                </button>
                <button class="review-filter" data-filter="positive" id="filter-pos">
                    Positive <span class="filter-count" id="count-pos">{{ kpi.positive|default(review_filters.positive_reviews) }}</span>
                </button>
                <button class="review-filter" data-filter="neutral" id="filter-neu">
                    Neutral <span class="filter-count" id="count-neu">{{ kpi.neutral|default(review_filters.neutral_reviews) }}</span>
                </button>
                <button class="review-filter" data-filter="negative" id="filter-neg">
                    Negative <span class="filter-count" id="count-neg">{{ kpi.negative|default(review_filters.negative_reviews) }}</span>
                </button>
            </div>

            <!-- Analysis Controls -->
            <div class="sidebar-section">
                <h3><i class="fas fa-cogs"></i> Analysis Controls</h3>
                
                <div class="filter-control">
                    <label>Packaging Keyword Frequencies:</label>
                    <select id="keyword-freq-select">
                        <option value="">-- Select a keyword to view frequency --</option>
                        {% for keyword, freq in packaging_freq.items() %}
                        <option value="{{ keyword }}">{{ keyword }} ({{ freq }})</option>
                        {% endfor %}
                    </select>
                </div>

                <div class="filter-control">
                    <label>Filter by Keywords:</label>
                    <input type="text" id="keyword-filter" placeholder="Enter keyword...">
                </div>

                <div class="filter-control">
                    <label>Filter by Packaging Terms:</label>
                    <select id="packaging-filter">
                        <option value="">-- Select packaging term --</option>
                        {% for term in packaging_terms %}
                        <option value="{{ term }}">{{ term }}</option>
                        {% endfor %}
                    </select>
                </div>

                <button class="action-btn btn-primary" onclick="showCooccurrenceNetwork()">
                    <i class="fas fa-project-diagram"></i> Co-occurrence Network
                </button>
                
                <button class="action-btn btn-warning" onclick="markDefectiveParts()">
                    <i class="fas fa-exclamation-triangle"></i> Mark Defective Parts
                </button>
                
                <button class="action-btn btn-success" onclick="resetFilters()">
                    <i class="fas fa-undo"></i> Reset Filters
                </button>
                

            </div>

            <!-- Downloads -->
            <div class="sidebar-section">
                <h3><i class="fas fa-download"></i> Downloads</h3>
                <a href="{{ excel_file }}" class="action-btn btn-primary">
                    <i class="fas fa-file-excel"></i> Download Excel Report
                </a>
                <a href="{{ packaging_library_url }}" class="action-btn btn-success">
                    <i class="fas fa-book"></i> Packaging Library
                </a>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Metrics Grid -->
            <div class="metrics-grid">
                <div class="metric-card">
                    <span class="metric-icon">üì¶</span>
                    <div class="metric-value" id="kpi-total">{{ kpi.total|default(total_reviews) }}</div>
                    <div class="metric-label">Total Reviews</div>
                </div>

                <div class="metric-card">
                    <span class="metric-icon">üîç</span>
                    <div class="metric-value" id="kpi-pack">{{ kpi.packaging_related|default(0) }}</div>
                    <div class="metric-label">Packaging Related</div>
                    <div style="font-size: 0.8em; color: #666; margin-top: 5px;">
                        {{ kpi.packaging_pct|default(0) }}% of total
                    </div>
                </div>

                <div class="metric-card">
                    <span class="metric-icon">üòä</span>
                    <div class="metric-value" id="kpi-positive">{{ kpi.positive|default(positive_count) }}</div>
                    <div class="metric-label">Positive Reviews</div>
                </div>

                <div class="metric-card">
                    <span class="metric-icon">üòê</span>
                    <div class="metric-value" id="kpi-neutral">{{ kpi.neutral|default(neutral_count) }}</div>
                    <div class="metric-label">Neutral Reviews</div>
                </div>

                <div class="metric-card">
                    <span class="metric-icon">üòû</span>
                    <div class="metric-value" id="kpi-negative">{{ kpi.negative|default(negative_count) }}</div>
                    <div class="metric-label">Negative Reviews</div>
                </div>

                <div class="metric-card">
                    <span class="metric-icon">‚ùå</span>
                    <div class="metric-value" id="kpi-defects">{{ kpi.defects|default(defect_pairs|length) }}</div>
                    <div class="metric-label">Defects Detected</div>
                </div>
            </div>

            <!-- Packaging Keyword Frequencies Word Cloud -->
            <div class="word-cloud-container">
                <h3><i class="fas fa-cloud"></i> PACKAGING KEYWORD FREQUENCIES</h3>
                <p>Hover over words to see their frequency in packaging-related reviews</p>
                <div id="wordcloud" style="position:relative; height:360px; border-radius:16px; overflow:hidden; background:rgba(255,255,255,0.06);"></div>
                <div class="word-tooltip" id="word-tooltip"></div>
            </div>

            <script>
                window.packagingFreq = {{ packaging_freq | default({}) | tojson }};
                window.packagingTerms = {{ packaging_terms | default([]) | tojson }};
            </script>

            <!-- Reviews Section -->
            <div class="reviews-section">
                <div class="reviews-header">
                    <div>
                        <div class="reviews-title">Product Reviews</div>
                        <div class="reviews-count">Showing <span id="visible-count">{{ reviews|length }}</span> of {{ reviews|length }} reviews</div>
                    </div>
                </div>

                <div id="reviews-container">
                    {% for review in reviews %}
                    <div class="review-card" data-sentiment="{{ review.sentiment if review.sentiment else 'neutral' }}" data-packaging="{{ 'true' if review.is_packaging_related else 'false' }}" data-rating="{{ review.rating or 0 }}" data-initial-display="{% if loop.index <= 10 %}block{% else %}none{% endif %}">
                        <div class="review-header">
                            <div class="reviewer-info">
                                <div class="reviewer-name">{{ review.reviewer_name or 'Anonymous' }}</div>
                                {% if review.review_title %}
                                <div class="review-title">{{ review.review_title }}</div>
                                {% endif %}
                            </div>
                            <div class="review-rating">
                                <div class="stars">
                                    {% if review.rating and review.rating is not none %}
                                        {% set rating = review.rating|float %}
                                        {% for i in range(5) %}
                                            {% if i < rating %}
                                                <i class="fas fa-star" style="color: #FFD700;"></i>
                                            {% else %}
                                                <i class="far fa-star" style="color: #FFD700;"></i>
                                            {% endif %}
                                        {% endfor %}
                                    {% else %}
                                        {% for i in range(5) %}
                                            <i class="far fa-star" style="color: #ccc;"></i>
                                        {% endfor %}
                                    {% endif %}
                                </div>
                                <span style="margin-left: 10px; font-weight: 600;">
                                    {% if review.rating and review.rating is not none %}
                                        {{ "%.1f"|format(review.rating) }}/5
                                    {% else %}
                                        N/A/5
                                    {% endif %}
                                </span>
                            </div>
                            <div class="review-date">{{ review.review_date or 'Date not available' }}</div>
                        </div>
                        
                        <div class="review-text">{{ review.review_text or 'No review text available' }}</div>
                        
                        {% if review.is_packaging_related %}
                        <div class="packaging-badge">
                            <i class="fas fa-box"></i> Packaging Related
                        </div>
                        {% endif %}
                        
                        {% if review.review_images %}
                        <div class="review-images">
                            {% for img_url in review.review_images %}
                            <img src="{{ img_url }}" alt="Review image" class="review-image" onclick="openImageModal('{{ img_url }}')">
                            {% endfor %}
                        </div>
                        {% endif %}
                    </div>
                    {% endfor %}
                </div>
                
                <!-- Pagination -->
                <div class="pagination-container">
                    <div class="pagination-info">
                        Showing <span id="current-page-info">1-10</span> of {{ reviews|length }} reviews
                    </div>
                    <div class="pagination-controls">
                        <button id="prev-page" class="pagination-btn" onclick="changePage(-1)" disabled>
                            <i class="fas fa-chevron-left"></i> Previous
                        </button>
                        <div class="page-numbers" id="page-numbers">
                            <!-- Page numbers will be generated by JavaScript -->
                        </div>
                        <button id="next-page" class="pagination-btn" onclick="changePage(1)">
                            Next <i class="fas fa-chevron-right"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Loading -->
    <div class="loading" id="loading">
        <div class="spinner"></div>
        <p>Processing...</p>
    </div>

    <!-- Chatbot -->
    <div class="chatbot-container">
        <button class="chatbot-toggle" onclick="toggleChatbot()">
            <i class="fas fa-comments"></i>
        </button>
        
        <div class="chatbot-modal" id="chatbot-modal">
            <div class="chatbot-header">
                <h3><i class="fas fa-robot"></i> PackSense Assistant</h3>
                <button class="chatbot-close" onclick="toggleChatbot()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="chatbot-messages" id="chatbot-messages">
                <div class="message bot-message">
                    <div class="message-content">
                        Hi! I'm your PackSense review assistant. üëã<br>
                        You can ask me to:<br>
                        ‚Ä¢ Summarize reviews<br>
                        ‚Ä¢ Extract packaging keywords<br>
                        ‚Ä¢ Sentiment summary<br>
                        ‚Ä¢ Common packaging issues<br>
                        ‚Ä¢ Show reviews about [keyword]<br>
                        ‚Ä¢ Show sentiment chart<br>
                        ‚Ä¢ Show wordcloud<br>
                        Type "help" for more commands!
                    </div>
                </div>
            </div>
            
            <div class="chatbot-input">
                <input type="text" id="chatbot-input" placeholder="Ask me about the reviews..." onkeypress="handleChatbotKeypress(event)">
                <button onclick="sendChatbotMessage()">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
    </div>

    <script>

        // Global filter functionality with proper state management
        window.currentNodes = [];
        window.currentLinks = [];
        let filterTimeout;
        const filterDelay = 300;
        
        // Controlled state for sliders
        let minStrength = 1;
        let minConnections = 1;
        
        // Global filter function
        window.applyFilters = function() {
            console.log('applyFilters called with state:', { minStrength, minConnections });
            
            // Use controlled state instead of reading from DOM
            if (window.currentNodes.length === 0) {
                console.log('No nodes available for filtering');
                return;
            }
            
            console.log('Applying filters:', { minStrength, minConnections });
            console.log('Total nodes available:', window.currentNodes.length);
            console.log('Total links available:', window.currentLinks.length);
            
            // Pure, ordered filter pipeline (no in-place mutation)
            console.log('Starting filter pipeline...');
            
            // Step 1: Start with all nodes (no weight filtering)
            const visibleNodes = window.currentNodes;
            console.log(`Starting with all nodes: ${visibleNodes.length}`);
            
            // Step 2: Filter nodes by number of connections (degree)
            const connectionsThreshold = minConnections <= 1 ? 0 : Math.floor(minConnections);
            console.log(`Connections threshold: ${connectionsThreshold}`);
            
            // Count connections for each visible node
            const nodeConnections = {};
            visibleNodes.forEach(node => {
                const connections = window.currentLinks.filter(link => {
                    const sourceId = link.source.id || link.source;
                    const targetId = link.target.id || link.target;
                    return sourceId === node.id || targetId === node.id;
                }).length;
                nodeConnections[node.id] = connections;
            });
            
            // Filter nodes by connection count
            const connectionFilteredNodes = visibleNodes.filter(node => {
                const connections = nodeConnections[node.id] || 0;
                const isVisible = connections >= connectionsThreshold;
                if (!isVisible) {
                    console.log(`Node "${node.name}" filtered out: connections=${connections} < threshold=${connectionsThreshold}`);
                }
                return isVisible;
            });
            
            console.log(`Connections filtering: ${visibleNodes.length} ‚Üí ${connectionFilteredNodes.length} nodes`);
            if (connectionFilteredNodes.length > 0) {
                console.log('Visible nodes after connections filter:', connectionFilteredNodes.map(n => `${n.name}(${nodeConnections[n.id]})`));
            }
            
            // Step 3: Rebuild edges to only those whose both ends are still visible
            const visibleLinks = window.currentLinks.filter(link => {
                const sourceId = link.source.id || link.source;
                const targetId = link.target.id || link.target;
                const sourceVisible = connectionFilteredNodes.some(n => n.id === sourceId);
                const targetVisible = connectionFilteredNodes.some(n => n.id === targetId);
                return sourceVisible && targetVisible;
            });
            console.log(`Edge filtering: ${window.currentLinks.length} ‚Üí ${visibleLinks.length} edges`);
            
            // Step 3: Compute normalization on this edge set
            if (visibleLinks.length === 0) {
                console.log('No connections match filters - rendering empty state');
                if (window.updateGraphVisibility) {
                    window.updateGraphVisibility([], []);
                }
                return;
            }
            
            const weights = visibleLinks.map(l => l.weight);
            const wMin = Math.min(...weights);
            const wMax = Math.max(...weights);
            
            console.log(`Edge weight range: min=${wMin}, max=${wMax}`);
            
            // Step 4: Filter edges by normalized strength
            const strengthThreshold = minStrength <= 1 ? 0 : Math.floor(minStrength);
            console.log(`Strength threshold: ${strengthThreshold}`);
            
            const strengthFilteredLinks = visibleLinks.filter(link => {
                let normalizedStrength;
                if (wMax === wMin) {
                    normalizedStrength = 3.0; // All edges have same weight
                } else {
                    normalizedStrength = 1 + 4 * (link.weight - wMin) / (wMax - wMin);
                }
                
                const isVisible = normalizedStrength >= strengthThreshold;
                if (!isVisible) {
                    console.log(`Link filtered out: ${link.source.id || link.source} -> ${link.target.id || link.target}, weight=${link.weight}, normalized=${normalizedStrength.toFixed(2)} < threshold=${strengthThreshold}`);
                }
                return isVisible;
            });
            
            console.log(`Strength filtering: ${visibleLinks.length} ‚Üí ${strengthFilteredLinks.length} edges`);
            
            if (strengthFilteredLinks.length > 0) {
                console.log('Visible links after strength filter:', strengthFilteredLinks.length);
            }
            // Step 5: Drop nodes with degree 0 after edge filtering
            const finalVisibleNodes = connectionFilteredNodes.filter(node => {
                const hasConnections = strengthFilteredLinks.some(link => 
                    (link.source.id || link.source) === node.id || 
                    (link.target.id || link.target) === node.id
                );
                if (!hasConnections) {
                    console.log(`Node "${node.name}" dropped: no connections after edge filtering`);
                }
                return hasConnections;
            });
            
            console.log(`Final result: ${finalVisibleNodes.length} nodes, ${strengthFilteredLinks.length} edges`);
            
            // Update the graph with final filtered data
            if (window.updateGraphVisibility) {
                window.updateGraphVisibility(finalVisibleNodes, strengthFilteredLinks);
            }
        };
        
        // Debounced filter application
        window.debouncedApplyFilters = function() {
            console.log('debouncedApplyFilters called, setting timeout...');
            clearTimeout(filterTimeout);
            filterTimeout = setTimeout(() => {
                console.log('Timeout fired, calling applyFilters...');
                window.applyFilters();
            }, filterDelay);
        };
        
        // Global variables for review data
        window.reviewsData = [];
        window.keywordSentenceMap = {};
        window.keywordImageMap = {};
        
        // Global variables for pagination and filtering
        let currentPage = 1;
        let currentFilter = 'all';
        let filteredReviews = [];
        const reviewsPerPage = 10;
        
        // Review filtering functionality
        document.addEventListener('DOMContentLoaded', function() {
            // Load review data into global variables
            console.log('Loading review data into global variables...');
            // Data will be loaded from the backend when showNodeDetails is called
            const filterButtons = document.querySelectorAll('.review-filter');
            const reviewCards = document.querySelectorAll('.review-card');
            const visibleCount = document.getElementById('visible-count');
            
            // Initialize with all reviews
            filteredReviews = Array.from(reviewCards);
            updateVisibleCount();
            showCurrentPageReviews();
            updatePagination();
            
            filterButtons.forEach(button => {
                button.addEventListener('click', function() {
                    // Remove active class from all buttons
                    filterButtons.forEach(btn => btn.classList.remove('active'));
                    // Add active class to clicked button
                    this.classList.add('active');
                    
                    const filter = this.getAttribute('data-filter');
                    currentFilter = filter;
                    currentPage = 1; // Reset to first page when filtering
                    
                    // Filter reviews based on selection
                    filteredReviews = Array.from(reviewCards).filter(card => {
                        switch(filter) {
                            case 'all':
                                return true;
                            case 'packaging':
                                return card.getAttribute('data-packaging') === 'true';
                            case 'positive':
                                return card.getAttribute('data-sentiment') === 'positive';
                            case 'neutral':
                                return card.getAttribute('data-sentiment') === 'neutral';
                            case 'negative':
                                return card.getAttribute('data-sentiment') === 'negative';
                            default:
                                return true;
                        }
                    });
                    
                    updateVisibleCount();
                    showCurrentPageReviews();
                    updatePagination();
                });
            });
        });
        
        // Word Cloud Generation - Futuristic Design with Dynamic Sizing
        function generateWordCloud() {
            const wordCloudContainer = document.getElementById('word-cloud');
            const tooltip = document.getElementById('word-tooltip');
            
            if (!wordCloudContainer) return;
            
            // Get keyword frequency data from the backend
            const keywordData = JSON.parse('{{ keyword_frequencies|tojson|safe }}');
            
            if (!keywordData || Object.keys(keywordData).length === 0) {
                wordCloudContainer.innerHTML = '<p style="color: white; margin-top: 50px; font-family: \'Rajdhani\', sans-serif;">No keyword data available</p>';
                return;
            }
            
            // Clear existing content
            wordCloudContainer.innerHTML = '';
            
            // Convert to array and sort by frequency
            const words = Object.entries(keywordData)
                .map(([word, count]) => ({ word, count }))
                .sort((a, b) => b.count - a.count);
            
            const containerWidth = wordCloudContainer.offsetWidth;
            const containerHeight = wordCloudContainer.offsetHeight;
            
            // Find min and max frequencies for scaling
            const maxFreq = Math.max(...words.map(w => w.count));
            const minFreq = Math.min(...words.map(w => w.count));
            
            // Store placed words for collision detection
            const placedWords = [];
            
            words.forEach((item, index) => {
                const wordElement = document.createElement('div');
                wordElement.className = 'word-cloud-word';
                wordElement.textContent = item.word;
                
                // Dynamic font size based on frequency (16px to 48px)
                const fontSize = 16 + (item.count / maxFreq) * 32;
                wordElement.style.fontSize = fontSize + 'px';
                
                // Assign frequency-based color class with more variety
                const freqRatio = item.count / maxFreq;
                const wordIndex = index; // Use word index for additional color variation
                
                if (freqRatio >= 0.8) {
                    // Extreme frequency - multiple hot colors
                    const extremeColors = ['word-freq-extreme-pink', 'word-freq-extreme-red', 'word-freq-extreme-purple'];
                    wordElement.classList.add(extremeColors[wordIndex % extremeColors.length]);
                } else if (freqRatio >= 0.6) {
                    // Very high frequency - warm colors
                    const veryHighColors = ['word-freq-very-high-red', 'word-freq-very-high-orange', 'word-freq-very-high-coral'];
                    wordElement.classList.add(veryHighColors[wordIndex % veryHighColors.length]);
                } else if (freqRatio >= 0.4) {
                    // High frequency - orange/yellow spectrum
                    const highColors = ['word-freq-high-orange', 'word-freq-high-yellow', 'word-freq-high-amber'];
                    wordElement.classList.add(highColors[wordIndex % highColors.length]);
                } else if (freqRatio >= 0.2) {
                    // Medium frequency - green/blue spectrum
                    const mediumColors = ['word-freq-medium-green', 'word-freq-medium-blue', 'word-freq-medium-teal'];
                    wordElement.classList.add(mediumColors[wordIndex % mediumColors.length]);
                } else {
                    // Low frequency - cool colors
                    const lowColors = ['word-freq-low-cyan', 'word-freq-low-blue', 'word-freq-low-purple'];
                    wordElement.classList.add(lowColors[wordIndex % lowColors.length]);
                }
                
                // Calculate word dimensions with enhanced padding
                const basePadding = fontSize * 0.3;
                const wordWidth = item.word.length * fontSize * 0.65 + basePadding * 2;
                const wordHeight = fontSize * 1.2 + basePadding * 2;
                
                // Enhanced collision detection with precise bounding box calculations
                function checkCollision(x, y, width, height) {
                    const padding = Math.max(fontSize * 0.4, 15); // Minimum 15px padding
                    
                    for (const placed of placedWords) {
                        // Bounding box collision detection with padding
                        const box1 = {
                            left: x - padding,
                            right: x + width + padding,
                            top: y - padding,
                            bottom: y + height + padding
                        };
                        
                        const box2 = {
                            left: placed.x - padding,
                            right: placed.x + placed.width + padding,
                            top: placed.y - padding,
                            bottom: placed.y + placed.height + padding
                        };
                        
                        // Check if boxes overlap
                        if (box1.left < box2.right && box1.right > box2.left &&
                            box1.top < box2.bottom && box1.bottom > box2.top) {
                            return true;
                        }
                    }
                    return false;
                }
                
                // Try to find a non-overlapping position with enhanced spiral layout
                let position = null;
                let attempts = 0;
                
                // Strategy 1: Enhanced spiral placement with collision-aware spacing
                while (attempts < 500 && !position) {
                    const centerX = containerWidth / 2;
                    const centerY = containerHeight / 2;
                    
                    // More controlled spiral with better spacing
                    const radiusStep = Math.max(fontSize * 0.8, 25);
                    const angleStep = 0.2; // Smaller angle steps for denser packing
                    const radius = radiusStep * Math.sqrt(attempts);
                    const angle = attempts * angleStep;
                    
                    const x = centerX + radius * Math.cos(angle) - wordWidth / 2;
                    const y = centerY + radius * Math.sin(angle) - wordHeight / 2;
                    
                    // Check bounds
                    if (x >= 0 && x <= containerWidth - wordWidth && 
                        y >= 0 && y <= containerHeight - wordHeight) {
                        
                        if (!checkCollision(x, y, wordWidth, wordHeight)) {
                            position = { x, y };
                        }
                    }
                    attempts++;
                }
                
                // Strategy 2: Grid-based placement with jittering
                if (!position) {
                    const gridSize = Math.max(fontSize, 30);
                    const cols = Math.floor(containerWidth / gridSize);
                    const rows = Math.floor(containerHeight / gridSize);
                    
                    for (let row = 0; row < rows && !position; row++) {
                        for (let col = 0; col < cols && !position; col++) {
                            // Base grid position
                            let x = col * gridSize + (gridSize - wordWidth) / 2;
                            let y = row * gridSize + (gridSize - wordHeight) / 2;
                            
                            // Add jittering for more organic look
                            const jitter = gridSize * 0.3;
                            x += (Math.random() - 0.5) * jitter;
                            y += (Math.random() - 0.5) * jitter;
                            
                            // Ensure bounds
                            x = Math.max(0, Math.min(x, containerWidth - wordWidth));
                            y = Math.max(0, Math.min(y, containerHeight - wordHeight));
                            
                            if (!checkCollision(x, y, wordWidth, wordHeight)) {
                                position = { x, y };
                            }
                        }
                    }
                }
                
                // Strategy 3: Adaptive random placement with collision retry
                if (!position) {
                    const maxRetries = 200;
                    const retryZones = [
                        { x: 0, y: 0, w: containerWidth, h: containerHeight }, // Full area
                        { x: containerWidth * 0.1, y: containerHeight * 0.1, w: containerWidth * 0.8, h: containerHeight * 0.8 }, // Center 80%
                        { x: containerWidth * 0.2, y: containerHeight * 0.2, w: containerWidth * 0.6, h: containerHeight * 0.6 }  // Center 60%
                    ];
                    
                    for (const zone of retryZones) {
                        if (position) break;
                        
                        for (let retry = 0; retry < maxRetries && !position; retry++) {
                            const x = zone.x + Math.random() * (zone.w - wordWidth);
                            const y = zone.y + Math.random() * (zone.h - wordHeight);
                            
                            if (x >= 0 && x <= containerWidth - wordWidth && 
                                y >= 0 && y <= containerHeight - wordHeight) {
                                
                                if (!checkCollision(x, y, wordWidth, wordHeight)) {
                                    position = { x, y };
                                }
                            }
                        }
                    }
                }
                
                // Strategy 4: Enhanced edge placement with collision detection
                if (!position) {
                    const margin = Math.max(fontSize * 0.5, 20);
                    const edges = [
                        {x: margin, y: margin}, // Top-left
                        {x: containerWidth - wordWidth - margin, y: margin}, // Top-right
                        {x: margin, y: containerHeight - wordHeight - margin}, // Bottom-left
                        {x: containerWidth - wordWidth - margin, y: containerHeight - wordHeight - margin}, // Bottom-right
                        {x: containerWidth / 2 - wordWidth / 2, y: margin}, // Top-center
                        {x: containerWidth / 2 - wordWidth / 2, y: containerHeight - wordHeight - margin}, // Bottom-center
                        {x: margin, y: containerHeight / 2 - wordHeight / 2}, // Left-center
                        {x: containerWidth - wordWidth - margin, y: containerHeight / 2 - wordHeight / 2} // Right-center
                    ];
                    
                    for (const edge of edges) {
                        if (edge.x >= 0 && edge.x <= containerWidth - wordWidth && 
                            edge.y >= 0 && edge.y <= containerHeight - wordHeight) {
                            
                            if (!checkCollision(edge.x, edge.y, wordWidth, wordHeight)) {
                                position = edge;
                                break;
                            }
                        }
                    }
                }
                
                // Final fallback - forced placement with warning
                if (!position) {
                    console.warn(`Unable to place word "${item.word}" without overlap. Forcing placement.`);
                    
                    // Try to find least conflicted position
                    let bestPosition = null;
                    let minConflicts = Infinity;
                    
                    for (let attempt = 0; attempt < 50; attempt++) {
                        const x = Math.random() * (containerWidth - wordWidth);
                        const y = Math.random() * (containerHeight - wordHeight);
                        
                        let conflicts = 0;
                        for (const placed of placedWords) {
                            if (checkCollision(x, y, wordWidth, wordHeight)) {
                                conflicts++;
                            }
                        }
                        
                        if (conflicts < minConflicts) {
                            minConflicts = conflicts;
                            bestPosition = { x, y };
                            if (conflicts === 0) break;
                        }
                    }
                    
                    position = bestPosition || { 
                        x: Math.random() * (containerWidth - wordWidth), 
                        y: Math.random() * (containerHeight - wordHeight) 
                    };
                }
                
                // Apply position to word element
                wordElement.style.left = position.x + 'px';
                wordElement.style.top = position.y + 'px';
                
                // Store word info for collision detection with exact bounding box
                placedWords.push({
                    x: position.x,
                    y: position.y,
                    width: wordWidth,
                    height: wordHeight,
                    word: item.word // For debugging
                });
                
                // Add hover events with enhanced tooltip
                wordElement.addEventListener('mouseenter', function(e) {
                    const freqPercentage = ((item.count / maxFreq) * 100).toFixed(1);
                    
                    // Get color based on frequency for tooltip with more variety
                    let tooltipColor = '#00ffff';
                    const colorIndex = wordIndex % 3; // Use same index for consistency
                    
                    if (freqPercentage >= 80) {
                        const extremeColors = ['#ff00ff', '#ff0000', '#cc00cc'];
                        tooltipColor = extremeColors[colorIndex];
                    } else if (freqPercentage >= 60) {
                        const veryHighColors = ['#ff4444', '#ff6600', '#ff6b6b'];
                        tooltipColor = veryHighColors[colorIndex];
                    } else if (freqPercentage >= 40) {
                        const highColors = ['#ff8c00', '#ffff00', '#ffcc00'];
                        tooltipColor = highColors[colorIndex];
                    } else if (freqPercentage >= 20) {
                        const mediumColors = ['#00ff00', '#00bfff', '#40e0d0'];
                        tooltipColor = mediumColors[colorIndex];
                    } else {
                        const lowColors = ['#00ffff', '#87ceeb', '#da70d6'];
                        tooltipColor = lowColors[colorIndex];
                    }
                    
                    tooltip.innerHTML = `
                        <div style="text-align: center;">
                            <div style="font-size: 16px; font-weight: 700; margin-bottom: 4px; color: ${tooltipColor};">${item.word}</div>
                            <div style="font-size: 12px; color: #00ffff;">${item.count} occurrences</div>
                            <div style="font-size: 10px; color: #e8f4fd;">${freqPercentage}% of max frequency</div>
                        </div>
                    `;
                    
                    // Position tooltip with smart positioning to avoid going out of bounds
                    const rect = wordElement.getBoundingClientRect();
                    const containerRect = wordCloudContainer.getBoundingClientRect();
                    const tooltipRect = tooltip.getBoundingClientRect();
                    
                    // Calculate positions
                    const wordCenterX = rect.left - containerRect.left + rect.width / 2;
                    const wordTop = rect.top - containerRect.top;
                    const wordBottom = wordTop + rect.height;
                    
                    // Check if tooltip would go out of bounds when positioned above
                    const tooltipHeight = 80; // Approximate tooltip height
                    const wouldGoAboveBounds = (wordTop - tooltipHeight - 10) < 0;
                    
                    // Position horizontally centered on the word
                    tooltip.style.left = wordCenterX + 'px';
                    
                    if (wouldGoAboveBounds) {
                        // Position below the word if it would go out of bounds above
                        tooltip.style.top = (wordBottom + 10) + 'px';
                        tooltip.style.transform = 'translateX(-50%) scale(1)';
                        // Update arrow to point up
                        tooltip.classList.add('arrow-up');
                    } else {
                        // Position above the word (default)
                        tooltip.style.top = (wordTop - tooltipHeight - 10) + 'px';
                        tooltip.style.transform = 'translateX(-50%) scale(1)';
                        // Update arrow to point down
                        tooltip.classList.remove('arrow-up');
                    }
                    
                    tooltip.classList.add('show');
                });
                
                wordElement.addEventListener('mouseleave', function() {
                    tooltip.classList.remove('show');
                });
                
                wordCloudContainer.appendChild(wordElement);
            });
        }
        
        // Initialize word cloud when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            generateWordCloud();
        });

        // Client-side safety net for dropdowns
        function hydrateSelect(id, items) {
            const el = document.getElementById(id);
            if (!el) return;
            const hasRealOptions = Array.from(el.options).some(o => o.value && !o.disabled);
            if (!hasRealOptions && items && items.length > 0) {
                items.forEach(t => {
                    const opt = document.createElement('option');
                    opt.value = t; 
                    opt.textContent = t;
                    el.appendChild(opt);
                });
            }
        }

        // Populate dropdowns on page load
        document.addEventListener('DOMContentLoaded', function() {
            hydrateSelect('keyword-freq-select', window.packagingTerms || []);
            hydrateSelect('packaging-filter', window.packagingTerms || []);
        });

        // Tooltip functionality matching localhost
        function showTooltip(event, word, count, percentage) {
            const tooltip = document.getElementById('word-tooltip');
            if (!tooltip) return;
            
            // Get color based on frequency for tooltip with more variety
            let tooltipColor = '#00ffff';
            const colorIndex = Math.floor(Math.random() * 3); // Use random index for variety
            
            if (percentage >= 80) {
                const extremeColors = ['#ff00ff', '#ff0000', '#cc00cc'];
                tooltipColor = extremeColors[colorIndex];
            } else if (percentage >= 60) {
                const veryHighColors = ['#ff4444', '#ff6600', '#ff6b6b'];
                tooltipColor = veryHighColors[colorIndex];
            } else if (percentage >= 40) {
                const highColors = ['#ff8c00', '#ffff00', '#ffcc00'];
                tooltipColor = highColors[colorIndex];
            } else if (percentage >= 20) {
                const mediumColors = ['#00ff00', '#00bfff', '#40e0d0'];
                tooltipColor = mediumColors[colorIndex];
            } else {
                const lowColors = ['#00ffff', '#87ceeb', '#da70d6'];
                tooltipColor = lowColors[colorIndex];
            }
            
            tooltip.innerHTML = `
                <div style="text-align: center;">
                    <div style="font-size: 16px; font-weight: 700; margin-bottom: 4px; color: ${tooltipColor};">${word}</div>
                    <div style="font-size: 12px; color: #00ffff;">${count} occurrences</div>
                    <div style="font-size: 10px; color: #e8f4fd;">${percentage}% of max frequency</div>
                </div>
            `;
            
            // Position tooltip with smart positioning to avoid going out of bounds
            const rect = event.target.getBoundingClientRect();
            const containerRect = document.getElementById('wordcloud').getBoundingClientRect();
            const tooltipRect = tooltip.getBoundingClientRect();
            
            // Calculate positions
            const wordCenterX = rect.left - containerRect.left + rect.width / 2;
            const wordTop = rect.top - containerRect.top;
            const wordBottom = wordTop + rect.height;
            
            // Check if tooltip would go out of bounds when positioned above
            const tooltipHeight = 80; // Approximate tooltip height
            const wouldGoAboveBounds = (wordTop - tooltipHeight - 10) < 0;
            
            // Position horizontally centered on the word
            tooltip.style.left = wordCenterX + 'px';
            
            if (wouldGoAboveBounds) {
                // Position below the word if it would go out of bounds above
                tooltip.style.top = (wordBottom + 10) + 'px';
                tooltip.style.transform = 'translateX(-50%) scale(1)';
                // Update arrow to point up
                tooltip.classList.add('arrow-up');
            } else {
                // Position above the word (default)
                tooltip.style.top = (wordTop - tooltipHeight - 10) + 'px';
                tooltip.style.transform = 'translateX(-50%) scale(1)';
                // Update arrow to point down
                tooltip.classList.remove('arrow-up');
            }
            
            tooltip.classList.add('show');
        }
        
        function hideTooltip() {
            const tooltip = document.getElementById('word-tooltip');
            if (tooltip) {
                tooltip.classList.remove('show');
            }
        }

        // Neon word cloud renderer (matching localhost design)
        (function renderNeonCloud(){
            const freqObj = window.packagingFreq || {};
            const entries = Object.entries(freqObj).filter(([k,v]) => k && Number(v)>0);
            const el = document.getElementById('wordcloud');
            
            console.log('Word cloud renderer called');
            console.log('packagingFreq:', freqObj);
            console.log('entries:', entries);
            console.log('wordcloud element:', el);
            
            if (!el) {
                console.error('Word cloud element not found!');
                return;
            }
            
            if (entries.length === 0) {
                console.warn('No word cloud entries found, showing fallback');
                el.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#666;font-size:1.2em;">No packaging keywords available</div>';
                return;
            }

            // Enhanced transparent neon background
            el.style.background =
                'radial-gradient(1200px 400px at 85% 25%, rgba(0,255,240,.08), transparent),' +
                'radial-gradient(1200px 400px at 20% 75%, rgba(255,0,160,.06), transparent),' +
                'radial-gradient(800px 300px at 50% 50%, rgba(255,255,255,.03), transparent),' +
                'linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.01))';
            el.style.border = '1px solid rgba(255,255,255,0.1)';
            el.style.borderRadius = '18px';

            if (!entries.length){
                el.innerHTML = '<div style="color:#bfc7cf;display:flex;height:100%;align-items:center;justify-content:center;">No packaging keywords available</div>';
                return;
            }

            // sort by weight and clamp to top-N if needed
            entries.sort((a,b)=>b[1]-a[1]);
            const TOP_N = 28;
            const data = entries.slice(0, TOP_N);

            const counts = data.map(d=>Number(d[1]));
            const minC = Math.min(...counts), maxC = Math.max(...counts);
            const size = c => {
                if (maxC===minC) return 26;
                const t = (c-minC)/(maxC-minC);
                return Math.round(18 + t*48); // 18‚Äì66px
            };

            // neon palette (H,S,L) -> we'll build gradients + glow
            const PALETTE = [
                [192,95,55],  // cyan
                [285,90,62],  // purple
                [118,92,48],  // green
                [15,96,60],   // orange
                [0,88,58],    // red
                [330,86,64],  // magenta
                [60,95,55],   // yellow
                [240,90,55],  // blue
                [300,85,60],  // pink
                [30,95,55],   // orange-red
            ];
            // Shuffle palette for more random color distribution
            const shuffledPalette = [...PALETTE].sort(() => Math.random() - 0.5);
            const colorFor = i => shuffledPalette[i % shuffledPalette.length];

            function pill(word, px, i, count){
                const [h,s,l] = colorFor(i);
                
                // Transparent neon styling matching localhost
                const baseColor = `hsl(${h} ${s}% ${l}%)`;
                const transparentBg = `hsla(${h} ${s}% ${l}% / 0.15)`;
                const borderColor = `hsla(${h} ${s}% ${Math.min(90, l+20)}% / 0.6)`;
                const textColor = `hsl(${h} ${s}% ${Math.min(95, l+30)}%)`;
                
                // Enhanced glow effects for authentic neon look
                const innerGlow = `inset 0 0 20px hsla(${h} ${s}% ${l}% / 0.3)`;
                const outerGlow1 = `0 0 5px hsla(${h} ${s}% ${l}% / 0.8)`;
                const outerGlow2 = `0 0 15px hsla(${h} ${s}% ${l}% / 0.6)`;
                const outerGlow3 = `0 0 30px hsla(${h} ${s}% ${l}% / 0.4)`;
                const outerGlow4 = `0 0 50px hsla(${h} ${s}% ${l}% / 0.2)`;

                const d = document.createElement('div');
                d.textContent = word;
                d.style.position   = 'absolute';
                d.style.fontFamily = 'Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto';
                d.style.fontWeight = '700';
                d.style.letterSpacing = '0.5px';
                d.style.fontSize  = px + 'px';
                d.style.padding   = '10px 20px';
                d.style.borderRadius = '20px';
                d.style.color     = textColor;
                d.style.background= transparentBg;
                d.style.border    = `2px solid ${borderColor}`;
                d.style.boxShadow = `${innerGlow}, ${outerGlow1}, ${outerGlow2}, ${outerGlow3}, ${outerGlow4}`;
                d.style.textShadow= `0 0 10px ${baseColor}, 0 0 20px ${baseColor}, 0 0 30px ${baseColor}`;
                d.style.userSelect= 'none';
                d.style.transform = `rotate(${(Math.random()-.5)*3}deg)`; // subtle rotation
                d.style.transition= 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
                d.style.cursor = 'pointer';
                d.style.backdropFilter = 'blur(10px)';
                d.style.borderImage = `linear-gradient(45deg, ${borderColor}, transparent, ${borderColor}) 1`;
                
                // Calculate percentage of max frequency
                const percentage = ((count / maxC) * 100).toFixed(1);
                
                d.onmouseenter = (e)=>{
                    // Enhanced hover effects matching localhost
                    d.style.transform = 'scale(1.3) rotate(2deg)';
                    d.style.zIndex = '100';
                    d.style.boxShadow = `0 0 30px ${baseColor}, 0 0 60px rgba(255,255,255,0.3)`;
                    d.style.background = 'rgba(255,255,255,0.15)';
                    d.style.borderColor = baseColor;
                    
                    // Show tooltip
                    showTooltip(e, word, count, percentage);
                };
                d.onmouseleave = ()=>{
                    // Reset to original state
                    d.style.transform = `rotate(${(Math.random()-.5)*3}deg)`;
                    d.style.zIndex = '';
                    d.style.boxShadow = `${innerGlow}, ${outerGlow1}, ${outerGlow2}, ${outerGlow3}, ${outerGlow4}`;
                    d.style.background = transparentBg;
                    d.style.borderColor = borderColor;
                    
                    // Hide tooltip
                    hideTooltip();
                };
                return d;
            }

            // clear & place with better spread algorithm
            el.innerHTML = '';
            const W = el.clientWidth, H = el.clientHeight;
            const placed = [];
            const minDistance = 40; // Minimum distance between words

            // Function to check if a position conflicts with existing words
            function hasConflict(x, y, width, height) {
                for (const existing of placed) {
                    const dx = Math.abs(x - existing.x);
                    const dy = Math.abs(y - existing.y);
                    if (dx < (width + existing.width) / 2 + minDistance && 
                        dy < (height + existing.height) / 2 + minDistance) {
                        return true;
                    }
                }
                return false;
            }

            // Function to find a good position for a word
            function findPosition(width, height) {
                const maxAttempts = 100;
                let attempts = 0;
                
                while (attempts < maxAttempts) {
                    // Try different strategies based on attempt number
                    let x, y;
                    
                    if (attempts < 30) {
                        // First 30 attempts: random placement
                        x = Math.random() * (W - width - 16) + 8;
                        y = Math.random() * (H - height - 16) + 8;
                    } else if (attempts < 60) {
                        // Next 30 attempts: spiral from center
                        const angle = (attempts - 30) * 0.3;
                        const radius = (attempts - 30) * 3;
                        x = W/2 + Math.cos(angle) * radius - width/2;
                        y = H/2 + Math.sin(angle) * radius - height/2;
                        x = Math.max(8, Math.min(W - width - 8, x));
                        y = Math.max(8, Math.min(H - height - 8, y));
                    } else {
                        // Final attempts: grid-based with jitter
                        const gridCols = 8;
                        const gridRows = 6;
                        const col = (attempts - 60) % gridCols;
                        const row = Math.floor((attempts - 60) / gridCols) % gridRows;
                        const cellW = (W - 16) / gridCols;
                        const cellH = (H - 16) / gridRows;
                        x = 8 + col * cellW + Math.random() * (cellW - width);
                        y = 8 + row * cellH + Math.random() * (cellH - height);
                    }
                    
                    if (!hasConflict(x, y, width, height)) {
                        return { x, y };
                    }
                    attempts++;
                }
                
                // Fallback: place at a random position even if it conflicts
                return {
                    x: Math.random() * (W - width - 16) + 8,
                    y: Math.random() * (H - height - 16) + 8
                };
            }

            // Place words with better distribution
            data.forEach(([w,c], idx)=>{
                const px = size(Number(c));
                const p = pill(w, px, idx, Number(c));
                el.appendChild(p); // append to measure

                const pos = findPosition(p.offsetWidth, p.offsetHeight);
                p.style.left = pos.x + 'px';
                p.style.top = pos.y + 'px';
                
                // Store position for conflict checking
                placed.push({
                    x: pos.x,
                    y: pos.y,
                    width: p.offsetWidth,
                    height: p.offsetHeight
                });
            });

            // responsive
            let raf=null;
            window.addEventListener('resize', ()=> {
                cancelAnimationFrame(raf);
                raf = requestAnimationFrame(renderNeonCloud);
            }, {once:true});
        })();
        
        // Update visible count
        function updateVisibleCount() {
            document.getElementById('visible-count').textContent = filteredReviews.length;
        }

        // Keyword filtering
        document.getElementById('keyword-filter').addEventListener('input', function() {
            const keyword = this.value.toLowerCase();
            const allReviewCards = document.querySelectorAll('.review-card');
            
            // Apply keyword filter to the current filtered reviews
            filteredReviews = Array.from(allReviewCards).filter(card => {
                const text = card.querySelector('.review-text').textContent.toLowerCase();
                return text.includes(keyword);
            });
            
            currentPage = 1; // Reset to first page
            updateVisibleCount();
            showCurrentPageReviews();
            updatePagination();
        });

        // Packaging term filtering
        document.getElementById('packaging-filter').addEventListener('change', function() {
            const term = this.value.toLowerCase();
            const allReviewCards = document.querySelectorAll('.review-card');
            
            if (!term) {
                // If no term selected, show all reviews based on current filter
                filteredReviews = Array.from(allReviewCards).filter(card => {
                    switch(currentFilter) {
                        case 'all':
                            return true;
                        case 'packaging':
                            return card.getAttribute('data-packaging') === 'true';
                        case 'positive':
                            return card.getAttribute('data-sentiment') === 'positive';
                        case 'neutral':
                            return card.getAttribute('data-sentiment') === 'neutral';
                        case 'negative':
                            return card.getAttribute('data-sentiment') === 'negative';
                        default:
                            return true;
                    }
                });
            } else {
                // Apply packaging term filter to the current filtered reviews
                filteredReviews = Array.from(allReviewCards).filter(card => {
                    const text = card.querySelector('.review-text').textContent.toLowerCase();
                    return text.includes(term);
                });
            }
            
            currentPage = 1; // Reset to first page
            updateVisibleCount();
            showCurrentPageReviews();
            updatePagination();
        });

        // Reset filters
        function resetFilters() {
            document.getElementById('keyword-filter').value = '';
            document.getElementById('packaging-filter').value = '';
            document.getElementById('keyword-freq-select').value = '';
            
            // Reset to all reviews
            const allReviewCards = document.querySelectorAll('.review-card');
            filteredReviews = Array.from(allReviewCards);
            currentFilter = 'all';
            currentPage = 1;
            
            // Reset filter buttons
            document.querySelectorAll('.review-filter').forEach(btn => btn.classList.remove('active'));
            document.querySelector('[data-filter="all"]').classList.add('active');
            
            updateVisibleCount();
            showCurrentPageReviews();
            updatePagination();
        }

        // Co-occurrence network
        function showCooccurrenceNetwork() {
            console.log('showCooccurrenceNetwork function called!');
            
            // Get co-occurrence data
            let cooccurrenceData = {};
            try {
                console.log('Raw co-occurrence data:', '{{ cooccurrence_data|tojson|safe }}');
                const parsedData = JSON.parse('{{ cooccurrence_data|tojson|safe }}');
                console.log('Parsed co-occurrence data:', parsedData);
                
                if (parsedData && Object.keys(parsedData).length > 0) {
                    cooccurrenceData = parsedData;
                } else {
                    // Use sample data if no real data
                    cooccurrenceData = {
                        "packaging": {"pack": 58, "container": 45, "bottle": 23},
                        "pack": {"packaging": 58, "bottle": 23, "leak": 12},
                        "container": {"packaging": 45, "leak": 12, "damage": 8},
                        "bottle": {"packaging": 23, "pack": 23, "leak": 15},
                        "leak": {"pack": 12, "container": 12, "bottle": 15}
                    };
                }
            } catch (error) {
                console.error('Error parsing co-occurrence data:', error);
                console.log('Using sample data instead');
                cooccurrenceData = {
                    "packaging": {"pack": 58, "container": 45, "bottle": 23},
                    "pack": {"packaging": 58, "bottle": 23, "leak": 12},
                    "container": {"packaging": 45, "leak": 12, "damage": 8},
                    "bottle": {"packaging": 23, "pack": 23, "leak": 15},
                    "leak": {"pack": 12, "container": 12, "bottle": 15}
                };
            }
            
            // Create modal for interactive network visualization
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: #000000;
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
            `;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: #000000;
                border-radius: 15px;
                padding: 30px;
                width: 95vw;
                height: 95vh;
                overflow: hidden;
                position: relative;
                display: flex;
                flex-direction: column;
            `;
            
            // Close button
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = '&times;';
            closeBtn.style.cssText = `
                position: absolute;
                top: 15px;
                right: 20px;
                background: none;
                border: none;
                font-size: 24px;
                cursor: pointer;
                color: #666;
                z-index: 1001;
            `;
            closeBtn.onclick = () => document.body.removeChild(modal);
            
            // Title with reset button
            const titleContainer = document.createElement('div');
            titleContainer.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin: 0 0 20px 0;
            `;
            
            const title = document.createElement('h2');
            title.textContent = 'Interactive Co-occurrence Network';
            title.style.cssText = `
                margin: 0;
                color: #ffffff;
                font-size: 1.5em;
            `;
            
            const resetButton = document.createElement('button');
            resetButton.textContent = 'Reset View';
            resetButton.style.cssText = `
                padding: 8px 16px;
                background: #ffffff;
                color: #000000;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 0.9em;
            `;
            resetButton.onclick = function() {
                // Reset sliders to default values based on actual data
                const strengthSlider = document.getElementById('connection-strength-slider');
                const connectionsSlider = document.getElementById('connections-slider');
                const strengthValue = document.getElementById('connection-strength-value');
                const connectionsValue = document.getElementById('connections-value');
                
                if (strengthSlider && connectionsSlider && strengthValue && connectionsValue) {
                    // Reset all sliders to 1 (show everything)
                    strengthSlider.value = 1;
                    connectionsSlider.value = 1;
                    strengthValue.textContent = '1';
                    connectionsValue.textContent = '1';
                    console.log('Reset button clicked - all sliders reset to 1');
                }
                
                // Reset global state
                minStrength = 1;
                minConnections = 1;
                
                // Show all nodes and links (reset to initial state)
                if (window.updateGraphVisibility) {
                    window.updateGraphVisibility(null, null); // This will show everything
                }
                
                // Reset info panel to default content
                infoPanel.innerHTML = `
                    <div style="text-align: center; color: #ffffff; padding: 50px 20px;">
                        <h3 style="margin: 0 0 20px 0; color: #ffffff;">Co-occurrence Network</h3>
                        <p style="margin: 0; font-size: 1.1em;">Click on any node to see related reviews and images</p>
                        <div style="margin-top: 30px; padding: 20px; background: #000000; border-radius: 8px; border: 1px solid #ffffff;">
                            <h4 style="margin: 0 0 15px 0; color: #ffffff;">Network Information</h4>
                            <p style="margin: 5px 0; color: #ffffff;"><strong>Total Nodes:</strong> <span id="node-count">-</span></p>
                            <p style="margin: 5px 0; color: #ffffff;"><strong>Total Connections:</strong> <span id="link-count">-</span></p>
                            <p style="margin: 5px 0; color: #ffffff;"><strong>Packaging Terms:</strong> <span id="term-count">-</span></p>
                        </div>
                    </div>
                `;
            };
            
            titleContainer.appendChild(title);
            titleContainer.appendChild(resetButton);
            
            // Filter controls section
            const filterContainer = document.createElement('div');
            filterContainer.style.cssText = `
                background: #000000;
                border-radius: 8px;
                padding: 20px;
                margin-bottom: 20px;
                border: 1px solid #ffffff;
            `;
            
            // Filter title
            const filterTitle = document.createElement('h4');
            filterTitle.textContent = 'Filter Controls';
            filterTitle.style.cssText = `
                margin: 0 0 15px 0;
                color: #ffffff;
                font-size: 1.1em;
            `;
            filterContainer.appendChild(filterTitle);
            
            // Filter controls row
            const filterRow = document.createElement('div');
            filterRow.style.cssText = `
                display: flex;
                gap: 30px;
                align-items: center;
                flex-wrap: wrap;
            `;
            

            
            // Min Connection Strength slider
            const strengthFilterGroup = document.createElement('div');
            strengthFilterGroup.style.cssText = `
                display: flex;
                flex-direction: column;
                gap: 8px;
                min-width: 200px;
            `;
            
            const strengthLabel = document.createElement('label');
            strengthLabel.textContent = 'Min Link Weight (1-5)';
            strengthLabel.setAttribute('for', 'connection-strength-slider');
            strengthLabel.style.cssText = `
                font-weight: 600;
                color: #ffffff;
                font-size: 0.9em;
            `;
            
            const strengthSliderContainer = document.createElement('div');
            strengthSliderContainer.style.cssText = `
                display: flex;
                align-items: center;
                gap: 10px;
            `;
            
            const strengthSlider = document.createElement('input');
            strengthSlider.type = 'range';
            strengthSlider.id = 'connection-strength-slider';
            strengthSlider.min = '1';
            strengthSlider.max = '5';
            strengthSlider.value = '1';
            strengthSlider.step = '0.1';
            strengthSlider.style.cssText = `
                flex: 1;
                height: 6px;
                border-radius: 3px;
                background: #ddd;
                outline: none;
                cursor: pointer;
            `;
            
            const strengthValue = document.createElement('span');
            strengthValue.id = 'connection-strength-value';
            strengthValue.textContent = '1';
            strengthValue.style.cssText = `
                font-weight: 600;
                color: #ffffff;
                min-width: 30px;
                text-align: center;
            `;
            
            strengthSliderContainer.appendChild(strengthSlider);
            strengthSliderContainer.appendChild(strengthValue);
            strengthFilterGroup.appendChild(strengthLabel);
            strengthFilterGroup.appendChild(strengthSliderContainer);
            
            // Min Connections slider
            const connectionsFilterGroup = document.createElement('div');
            connectionsFilterGroup.style.cssText = `
                display: flex;
                flex-direction: column;
                gap: 8px;
                min-width: 200px;
            `;
            
            const connectionsLabel = document.createElement('label');
            connectionsLabel.textContent = 'Min Connections';
            connectionsLabel.setAttribute('for', 'connections-slider');
            connectionsLabel.style.cssText = `
                font-weight: 600;
                color: #ffffff;
                font-size: 0.9em;
            `;
            
            const connectionsSliderContainer = document.createElement('div');
            connectionsSliderContainer.style.cssText = `
                display: flex;
                align-items: center;
                gap: 10px;
            `;
            
            const connectionsSlider = document.createElement('input');
            connectionsSlider.type = 'range';
            connectionsSlider.id = 'connections-slider';
            connectionsSlider.min = '1';
            connectionsSlider.max = '50'; // Will be updated dynamically based on actual data
            connectionsSlider.value = '1';
            connectionsSlider.step = '1';
            connectionsSlider.style.cssText = `
                flex: 1;
                height: 6px;
                border-radius: 3px;
                background: #ddd;
                outline: none;
                cursor: pointer;
            `;
            
            const connectionsValue = document.createElement('span');
            connectionsValue.id = 'connections-value';
            connectionsValue.textContent = '1';
            connectionsValue.style.cssText = `
                font-weight: 600;
                color: #ffffff;
                min-width: 30px;
                text-align: center;
            `;
            
            connectionsSliderContainer.appendChild(connectionsSlider);
            connectionsSliderContainer.appendChild(connectionsValue);
            connectionsFilterGroup.appendChild(connectionsLabel);
            connectionsFilterGroup.appendChild(connectionsSliderContainer);
            
            // Add event listeners immediately after sliders are created
            console.log('Adding event listeners to sliders');
            
            strengthSlider.addEventListener('input', function(event) {
                const newValue = parseFloat(event.currentTarget.value);
                minStrength = newValue;
                
                const strengthValue = document.getElementById('connection-strength-value');
                if (strengthValue) strengthValue.textContent = newValue;
                
                console.log('Strength slider changed to:', newValue);
                console.log('Updated state minStrength:', minStrength);
                console.log('Calling debouncedApplyFilters...');
                window.debouncedApplyFilters();
            });
            
            connectionsSlider.addEventListener('input', function(event) {
                const newValue = parseInt(event.currentTarget.value);
                minConnections = newValue;
                
                const connectionsValue = document.getElementById('connections-value');
                if (connectionsValue) connectionsValue.textContent = newValue;
                
                console.log('Connections slider changed to:', newValue);
                console.log('Updated state minConnections:', minConnections);
                console.log('Calling debouncedApplyFilters...');
                window.debouncedApplyFilters();
            });
            
            console.log('Event listeners added successfully');
            
            // Legend
            const legend = document.createElement('div');
            legend.style.cssText = `
                font-size: 0.85em;
                color: #ffffff;
                font-style: italic;
                margin-top: 10px;
                padding: 10px;
                background: #000000;
                border-radius: 5px;
                border-left: 3px solid #ffffff;
            `;
            legend.innerHTML = 'Simple filtering: Min Link Weight 3 = show links with weight ‚â• 3, Min Connections 5 = show nodes with ‚â• 5 connections. Lower values show more, higher values show less.';
            

            
            filterRow.appendChild(strengthFilterGroup);
            filterRow.appendChild(connectionsFilterGroup);
            filterContainer.appendChild(filterRow);
            filterContainer.appendChild(legend);
            

            
            // Network container with integrated layout
            const networkContainer = document.createElement('div');
            networkContainer.id = 'network-container';
            networkContainer.style.cssText = `
                flex: 1;
                min-height: 600px;
                background: #000000;
                border-radius: 10px;
                position: relative;
                overflow: hidden;
                display: flex;
            `;
            
            // SVG container for network
            const svgContainer = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svgContainer.id = 'cooc-svg';
            svgContainer.style.cssText = `
                flex: 2;
                position: relative;
                overflow: hidden;
                background: #000;
                border-radius: 8px;
            `;
            
            // Info panel integrated into the layout
            const infoPanel = document.createElement('div');
            infoPanel.id = 'cooc-stats';
            infoPanel.style.cssText = `
                flex: 1;
                background: white;
                border-left: 2px solid #eee;
                padding: 25px;
                max-height: 100%;
                overflow-y: auto;
                display: block;
                box-shadow: -4px 0 15px rgba(0,0,0,0.1);
            `;
            
            // Add default content to info panel
            infoPanel.innerHTML = `
                <div style="text-align: center; color: #666; padding: 50px 20px;">
                    <h3 style="margin: 0 0 20px 0; color: #333;">Co-occurrence Network</h3>
                    <p style="margin: 0; font-size: 1.1em;">Click on any node to see related reviews and images</p>
                    <div style="margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px;">
                        <h4 style="margin: 0 0 15px 0; color: #333;">Network Information</h4>
                        <p style="margin: 5px 0; color: #666;"><strong>Total Nodes:</strong> <span class="nodes-count">-</span></p>
                        <p style="margin: 5px 0; color: #666;"><strong>Total Connections:</strong> <span class="links-count">-</span></p>
                        <p style="margin: 5px 0; color: #666;"><strong>Packaging Terms:</strong> <span class="terms-count">-</span></p>
                    </div>
                </div>
            `;
            
            networkContainer.appendChild(svgContainer);
            networkContainer.appendChild(infoPanel);
            
            modalContent.appendChild(closeBtn);
            modalContent.appendChild(titleContainer);
            modalContent.appendChild(networkContainer);
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Add event listeners after modal is created

            
            // Create interactive network visualization
            console.log('About to create network visualization...');
            console.log('Container:', networkContainer);
            console.log('Info panel:', infoPanel);
            
            // Use the new D3 implementation
            const coocBase = {{ cooc_graph | default({'nodes':[], 'links':[]}) | tojson }};
            console.log('Co-occurrence base data:', coocBase);
            console.log('Nodes count:', coocBase.nodes?.length || 0);
            console.log('Links count:', coocBase.links?.length || 0);
            console.log('D3 available:', typeof d3 !== 'undefined');
            console.log('SVG element:', modal.querySelector("#cooc-svg"));
            
            if (!coocBase.nodes || coocBase.nodes.length === 0) {
                console.error('No nodes in co-occurrence data!');
            }
            if (!coocBase.links || coocBase.links.length === 0) {
                console.error('No links in co-occurrence data!');
            }
            
            initCoocNetwork(coocBase, modal);
        }
        
        // Bulletproof D3 co-occurrence network implementation
        function initCoocNetwork(base, modal) {
            console.log('initCoocNetwork called with:', base);
            const baseGraph = base || {nodes:[], links:[]};
            console.log('baseGraph:', baseGraph);
            const svg = d3.select(modal.querySelector("#cooc-svg"));
            console.log('SVG element found:', !!svg.node());
            if (!svg.node()) {
                console.error('SVG element not found!');
                return;
            }

            const width = 900;
            const height = 540;
            svg.attr("width", width).attr("height", height);

            const gLinks = svg.append("g").attr("stroke","#b8b8b8").attr("stroke-opacity",0.55);
            const gNodes = svg.append("g");

            const stats = {
                set(n,l){ 
                    const rt = modal.querySelector('#cooc-stats');
                    if (!rt) return;
                    const nodesEl = rt.querySelector('.nodes-count');
                    const linksEl = rt.querySelector('.links-count');
                    const termsEl = rt.querySelector('.terms-count');
                    if (nodesEl) nodesEl.textContent = n;
                    if (linksEl) linksEl.textContent = l;
                    if (termsEl) termsEl.textContent = n;
                }
            };

            const r = d3.scaleSqrt()
                .domain(d3.extent(baseGraph.nodes, d => +d.count || 1))
                .range([10, 36]);

            function filter(minW, minDeg){
                console.log('Filtering with minW:', minW, 'minDeg:', minDeg);
                console.log('Base graph nodes:', baseGraph.nodes.length, 'links:', baseGraph.links.length);
                
                // Filter links by weight
                const links = baseGraph.links.filter(e => (e.weight||1) >= minW);
                console.log('Links after weight filter:', links.length);
                
                // Count connections for each node
                const deg = {};
                links.forEach(e => {
                    deg[e.source] = (deg[e.source]||0)+1;
                    deg[e.target] = (deg[e.target]||0)+1;
                });
                console.log('Node degrees:', deg);
                
                // Filter nodes by minimum connections
                const nodes = baseGraph.nodes.filter(n => (deg[n.id]||0) >= (minDeg||0));
                console.log('Nodes after degree filter:', nodes.length);
                
                // Keep only links with both ends present
                const N = new Set(nodes.map(n=>n.id));
                const L = links.filter(e => N.has(e.source) && N.has(e.target));
                console.log('Final links:', L.length);
                
                return {nodes, links: L};
            }

            function draw(minW, minDeg){
                const graph = filter(minW, minDeg);

                // if empty, auto-relax for a visible default view
                if (!graph.nodes.length || !graph.links.length) {
                    const relaxed = filter(1, 0);
                    if (relaxed.nodes.length && relaxed.links.length) {
                        return draw(1, 0);
                    }
                }

                const link = gLinks.selectAll("line").data(graph.links, d => d.source+'|'+d.target);
                link.exit().remove();
                const linkEnter = link.enter().append("line").attr("stroke-width", d => 0.7 + (d.weight||1)*0.6);
                const linkAll = linkEnter.merge(link);

                const node = gNodes.selectAll("g.node").data(graph.nodes, d => d.id);
                node.exit().remove();
                const nodeEnter = node.enter().append("g").attr("class","node").call(d3.drag()
                    .on("start", dragstarted).on("drag", dragged).on("end", dragended));

                nodeEnter.append("circle")
                    .attr("r", d => r(+d.count || 1))
                    .attr("fill","#fff").attr("stroke","#333").attr("stroke-width",1.2)
                    .style("cursor", "pointer");

                nodeEnter.append("text")
                    .attr("text-anchor","middle").attr("dy",".35em")
                    .style("font-size","12px").style("pointer-events","none")
                    .text(d => d.label || d.id);

                // Add click functionality to show reviews
                nodeEnter.on("click", function(event, d) {
                    console.log('Node clicked:', d);
                    showNodeReviews(d, modal);
                });

                const nodeAll = nodeEnter.merge(node);

                const sim = d3.forceSimulation(graph.nodes)
                    .force("link", d3.forceLink(graph.links)
                        .id(d => d.id)                   // <<< binds links to node.id
                        .distance(d => 42 + (6-(d.weight||1))*6)
                        .strength(d => 0.1 + (d.weight||1)*0.05))
                    .force("charge", d3.forceManyBody().strength(-150))
                    .force("center", d3.forceCenter(width/2, height/2))
                    .on("tick", ticked);

                function ticked(){
                    linkAll
                        .attr("x1", d => d.source.x).attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
                    nodeAll.attr("transform", d => `translate(${d.x},${d.y})`);
                }
                function dragstarted(ev,d){ if(!ev.active) sim.alphaTarget(0.3).restart(); d.fx=d.x; d.fy=d.y; }
                function dragged(ev,d){ d.fx=ev.x; d.fy=ev.y; }
                function dragended(ev,d){ if(!ev.active) sim.alphaTarget(0); d.fx=null; d.fy=null; }

                // D3 elements are local to this function

                stats.set(graph.nodes.length, graph.links.length);
            }

            // No filtering for demo version - show all data
            draw(1, 1); // initial draw with no filtering
        }

        // Function to show full review in a modal
        function showFullReviewModal(reviewId, reviewText, headline, reviewerName, rating) {
            console.log('Showing full review modal for:', reviewId);
            
            // Create modal overlay
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                z-index: 10000;
                display: flex;
                justify-content: center;
                align-items: center;
                padding: 20px;
            `;
            
            // Create modal content
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                border-radius: 12px;
                padding: 30px;
                max-width: 600px;
                width: 100%;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                position: relative;
            `;
            
            // Create close button
            const closeButton = document.createElement('button');
            closeButton.innerHTML = '√ó';
            closeButton.style.cssText = `
                position: absolute;
                top: 15px;
                right: 20px;
                background: none;
                border: none;
                font-size: 24px;
                cursor: pointer;
                color: #666;
                width: 30px;
                height: 30px;
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 50%;
                transition: background 0.2s;
            `;
            closeButton.onmouseover = () => closeButton.style.background = '#f0f0f0';
            closeButton.onmouseout = () => closeButton.style.background = 'none';
            closeButton.onclick = () => document.body.removeChild(modal);
            
            // Create stars
            const stars = '‚òÖ'.repeat(rating) + '‚òÜ'.repeat(5 - rating);
            
            // Modal content HTML
            modalContent.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h2 style="margin: 0; color: #333; font-size: 24px;">${headline}</h2>
                        <div style="color: #ffc107; font-size: 20px;">${stars}</div>
                    </div>
                    <div style="color: #666; font-size: 14px; margin-bottom: 20px;">
                        By ${reviewerName} ‚Ä¢ Review ID: ${reviewId}
                    </div>
                </div>
                
                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; border-left: 4px solid #007bff;">
                    <h3 style="margin: 0 0 15px 0; color: #333; font-size: 18px;">Full Review</h3>
                    <div style="line-height: 1.6; color: #333; font-size: 16px;">
                        ${reviewText.replace(/\n/g, '<br>')}
                    </div>
                </div>
                
                <div style="margin-top: 20px; text-align: center;">
                    <button onclick="document.body.removeChild(this.closest('.modal-overlay'))" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px;">
                        Close
                    </button>
                </div>
            `;
            
            modalContent.appendChild(closeButton);
            modal.appendChild(modalContent);
            modal.className = 'modal-overlay';
            document.body.appendChild(modal);
            
            // Close on overlay click
            modal.onclick = (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            };
        }

        // Function to show reviews for a clicked node (matching localhost format)
        function showNodeReviews(node, modal) {
            console.log('Showing reviews for node:', node);
            
            // Get all reviews from the page
            const allReviews = window.allReviews || [];
            console.log('Total reviews available:', allReviews.length);
            
            // Filter reviews that contain this term
            const term = node.id || node.label;
            const relatedReviews = allReviews.filter(review => {
                const reviewText = (review.review_text || '').toLowerCase();
                return reviewText.includes(term.toLowerCase());
            });
            
            console.log(`Found ${relatedReviews.length} reviews containing "${term}"`);
            
            // Update the info panel with localhost-style display
            const infoPanel = modal.querySelector('#cooc-stats');
            if (infoPanel) {
                infoPanel.innerHTML = `
                    <div style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <h3 style="margin: 0 0 10px 0; color: #333; font-size: 18px;">${node.connections || 0} Connections</h3>
                        <p style="margin: 0 0 5px 0; color: #666; font-size: 14px;">${node.totalWeight || 0} Total Weight</p>
                        <p style="margin: 0; color: #666; font-size: 14px;">${relatedReviews.length} Reviews Found</p>
                    </div>
                    
                    <h3 style="color: #333; margin-bottom: 15px;">${relatedReviews.length} Reviews Containing '${term}'</h3>
                    
                    <div style="max-height: 500px; overflow-y: auto;">
                        ${relatedReviews.slice(0, 20).map((review, index) => {
                            const rating = review.rating || 5;
                            const stars = '‚òÖ'.repeat(rating) + '‚òÜ'.repeat(5 - rating);
                            const headline = review.headline || review.title || 'Great product';
                            const reviewText = review.review_text || '';
                            
                            // Find sentence containing the term
                            const sentences = reviewText.split(/[.!?]+/);
                            const termSentence = sentences.find(s => s.toLowerCase().includes(term.toLowerCase()));
                            const highlightedSentence = termSentence ? 
                                termSentence.replace(new RegExp(`(${term})`, 'gi'), '<mark style="background: yellow; padding: 2px;">$1</mark>') : 
                                reviewText.substring(0, 100) + '...';
                            
                            return `
                                <div style="background: white; padding: 20px; margin-bottom: 15px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); border-left: 4px solid #007bff;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                        <div style="font-weight: bold; color: #333;">${review.reviewer_name || 'Anonymous'}</div>
                                        <div style="color: #666; font-size: 12px;">${review.date || 'Recent'}</div>
                                    </div>
                                    
                                    <div style="margin-bottom: 10px;">
                                        <div style="color: #ffc107; font-size: 16px; margin-bottom: 5px;">${stars}</div>
                                        <div style="font-weight: bold; color: #333; margin-bottom: 8px;">${headline}</div>
                                    </div>
                                    
                                    ${termSentence ? `
                                        <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; margin-bottom: 10px; border: 1px solid #e9ecef;">
                                            <div style="font-size: 14px; line-height: 1.5; color: #333;">
                                                ${highlightedSentence}
                                            </div>
                                        </div>
                                    ` : ''}
                                    
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <div style="font-size: 12px; color: #666;">
                                            Sentiment: <span style="color: ${review.sentiment === 'positive' ? '#28a745' : review.sentiment === 'negative' ? '#dc3545' : '#6c757d'};">${review.sentiment || 'neutral'}</span> | 
                                            Packaging Related: <span style="color: ${review.is_packaging_related ? '#28a745' : '#dc3545'};">${review.is_packaging_related ? 'Yes' : 'No'}</span>
                                        </div>
                                                                                    <button onclick="showFullReviewModal('${review.review_id || index}', '${review.review_text || ''}', '${review.headline || review.title || 'Great product'}', '${review.reviewer_name || 'Anonymous'}', '${review.rating || 5}')" style="background: #007bff; color: white; border: none; padding: 5px 10px; border-radius: 4px; font-size: 12px; cursor: pointer;">
                                                Show Full Review
                                            </button>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                        
                        ${relatedReviews.length > 20 ? `
                            <div style="text-align: center; margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                                <p style="margin: 0; color: #666;">Showing first 20 of ${relatedReviews.length} reviews</p>
                                <button onclick="loadMoreReviews('${term}')" style="background: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 4px; margin-top: 10px; cursor: pointer;">
                                    Load More Reviews
                                </button>
                            </div>
                        ` : ''}
                    </div>
                `;
            }
        }
        
        // Create interactive network visualization
        function createInteractiveNetwork(data, container, infoPanel) {
            console.log('Creating interactive network with data:', data);
            
            // Get the SVG container
            const svgContainer = container.querySelector('#svg-container');
            if (!svgContainer) {
                console.error('SVG container not found!');
                return;
            }
            
            // Clear SVG container
            svgContainer.innerHTML = '';
            
            // Check if D3.js is available
            if (typeof d3 === 'undefined') {
                console.error('D3.js is not loaded!');
                svgContainer.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: #666;">
                        <h3>D3.js Library Error</h3>
                        <p>D3.js library failed to load. Please refresh the page and try again.</p>
                        <button onclick="location.reload()" style="padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer;">
                            Refresh Page
                        </button>
                    </div>
                `;
                return;
            }
            
            // Process data for network visualization
            const nodes = [];
            const links = [];
            const nodeMap = new Map();
            
            // Create nodes
            let nodeId = 0;
            for (const [term, connections] of Object.entries(data)) {
                if (!nodeMap.has(term)) {
                    nodeMap.set(term, nodeId++);
                    nodes.push({
                        id: term,
                        name: term,
                        connections: Object.keys(connections).length,
                        totalWeight: Object.values(connections).reduce((a, b) => a + b, 0)
                    });
                }
                
                for (const [targetTerm, weight] of Object.entries(connections)) {
                    if (!nodeMap.has(targetTerm)) {
                        nodeMap.set(targetTerm, nodeId++);
                        nodes.push({
                            id: targetTerm,
                            name: targetTerm,
                            connections: 0,
                            totalWeight: 0
                        });
                    }
                    
                    links.push({
                        source: term,
                        target: targetTerm,
                        weight: weight
                    });
                }
            }
            
            // Update connection counts
            links.forEach(link => {
                const sourceNode = nodes.find(n => n.id === link.source);
                const targetNode = nodes.find(n => n.id === link.target);
                if (sourceNode) sourceNode.connections++;
                if (targetNode) targetNode.connections++;
            });
            
            console.log('Processed nodes:', nodes);
            console.log('Processed links:', links);
            
            // Store nodes and links for filtering
            window.currentNodes = nodes;
            window.currentLinks = links;
            
            console.log('Stored nodes for filtering:', window.currentNodes.length);
            console.log('Stored links for filtering:', window.currentLinks.length);
            
            // Update slider ranges based on actual data
            // Calculate connection counts for each node
            const nodeConnections = {};
            nodes.forEach(node => {
                const connections = links.filter(link => {
                    const sourceId = link.source.id || link.source;
                    const targetId = link.target.id || link.target;
                    return sourceId === node.id || targetId === node.id;
                }).length;
                nodeConnections[node.id] = connections;
            });
            
            const maxConnections = Math.max(...Object.values(nodeConnections));
            const minConnections = Math.min(...Object.values(nodeConnections));
            
            console.log(`Data ranges - Connections: min=${minConnections}, max=${maxConnections}`);
            
            // Update Connections slider (actual range)
            const connectionsSlider = document.getElementById('connections-slider');
            if (connectionsSlider) {
                connectionsSlider.min = minConnections.toString();
                connectionsSlider.max = maxConnections.toString();
                connectionsSlider.value = minConnections.toString();
                console.log(`Updated connections slider: min=${minConnections}, max=${maxConnections}, value=${minConnections}`);
                
                const connectionsValue = document.getElementById('connections-value');
                if (connectionsValue) connectionsValue.textContent = minConnections.toString();
            }
            
            // Update Link Weight slider (1-5 scale, already set)
            const strengthSlider = document.getElementById('connection-strength-slider');
            if (strengthSlider) {
                strengthSlider.min = '1';
                strengthSlider.max = '5';
                strengthSlider.value = '1';
                console.log(`Updated link weight slider: min=1, max=5, value=1`);
                
                const strengthValue = document.getElementById('connection-strength-value');
                if (strengthValue) strengthValue.textContent = '1';
            }
            
            // Don't apply initial filters - show everything normally
            // Filters will only be applied when user moves the sliders
            
            if (nodes.length === 0) {
                container.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: #666;">
                        <h3>No Data Available</h3>
                        <p>No co-occurrence data found. Please try analyzing a different product.</p>
                    </div>
                `;
                return;
            }
            
            // Create SVG for network visualization
            const svg = d3.select(svgContainer)
                .append('svg')
                .attr('width', '100%')
                .attr('height', '100%')
                .style('background', '#000000')
                .style('border-radius', '10px');
            
            // Get container dimensions
            const width = svgContainer.clientWidth || 800;
            const height = svgContainer.clientHeight || 600;
            
            console.log('Container dimensions:', width, height);
            
            // Create force simulation with better parameters for clearer visualization
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(300).strength(0.1))
                .force('charge', d3.forceManyBody().strength(-1200).distanceMax(400))
                .force('center', d3.forceCenter(width / 2, height / 2).strength(0.1))
                .force('collision', d3.forceCollide().radius(80).strength(0.8))
                .force('x', d3.forceX(width / 2).strength(0.01))
                .force('y', d3.forceY(height / 2).strength(0.01));
            
            // Create links with clearer styling
            const link = svg.append('g')
                .selectAll('line')
                .data(links)
                .enter().append('line')
                .attr('stroke', '#C0C0C0')
                .attr('stroke-opacity', 0.9)
                .attr('stroke-width', d => Math.max(1.5, Math.sqrt(d.weight) * 1.8))
                .style('filter', 'drop-shadow(0 1px 2px rgba(255,255,255,0.3))');
            
            // Create nodes with smaller, more consistent sizing
            const node = svg.append('g')
                .selectAll('circle')
                .data(nodes)
                .enter().append('circle')
                .attr('r', d => Math.max(20, Math.sqrt(d.connections) * 8))
                .attr('fill', '#ffffff')
                .attr('stroke', '#000000')
                .attr('stroke-width', 3)
                .style('cursor', 'pointer')
                .style('transition', 'all 0.3s ease')
                .style('filter', 'drop-shadow(0 2px 4px rgba(255,255,255,0.3))')
                .on('mouseover', function(event, d) {
                    console.log('Mouse over node:', d.name);
                    
                    // Enlarge the node slightly
                    d3.select(this).attr('r', d => Math.max(20, Math.sqrt(d.connections) * 8));
                    
                    // Highlight connected links with clearer visibility
                    link.attr('stroke-opacity', l => 
                        l.source.id === d.id || l.target.id === d.id ? 1 : 0.2
                    ).attr('stroke-width', l => 
                        l.source.id === d.id || l.target.id === d.id ? Math.max(2, Math.sqrt(l.weight) * 2) : Math.max(0.5, Math.sqrt(l.weight) * 0.8)
                    );
                    
                    // Highlight connected nodes
                    node.attr('opacity', n => 
                        n.id === d.id || links.some(l => 
                            (l.source.id === d.id && l.target.id === n.id) ||
                            (l.target.id === d.id && l.source.id === n.id)
                        ) ? 1 : 0.4
                    );
                })
                .on('mouseout', function(event, d) {
                    console.log('Mouse out node:', d.name);
                    
                    // Reset node size
                    d3.select(this).attr('r', d => Math.max(15, Math.sqrt(d.connections) * 6));
                    
                    // Reset link opacity and width
                    link.attr('stroke-opacity', 0.9).attr('stroke-width', d => Math.max(1.5, Math.sqrt(d.weight) * 1.8));
                    
                    // Reset node opacity
                    node.attr('opacity', 1);
                })
                .on('click', function(event, d) {
                    console.log('Clicked node:', d.name);
                    event.stopPropagation();
                    
                    // Show detailed information in info panel
                    showNodeDetails(d, infoPanel);
                    
                    // Highlight selected node and connected nodes
                    node.attr('opacity', n => 
                        n.id === d.id || links.some(l => 
                            (l.source.id === d.id && l.target.id === n.id) ||
                            (l.target.id === d.id && l.source.id === n.id)
                        ) ? 1 : 0.4
                    );
                    link.attr('stroke-opacity', l => 
                        l.source.id === d.id || l.target.id === d.id ? 1 : 0.2
                    );
                });
            
            // Add node labels with better styling
            const label = svg.append('g')
                .selectAll('text')
                .data(nodes)
                .enter().append('text')
                .text(d => d.name)
                .attr('text-anchor', 'middle')
                .attr('dy', '.35em')
                .attr('font-size', '14px')
                .attr('font-weight', '600')
                .attr('fill', '#000000')
                .style('pointer-events', 'none')
                .style('text-shadow', '0 1px 2px rgba(255,255,255,0.9)')
                .style('font-family', 'Inter, -apple-system, BlinkMacSystemFont, sans-serif');
            
            // Set initial positions to spread nodes out in a larger circle
            nodes.forEach((node, i) => {
                const angle = (i / nodes.length) * 2 * Math.PI;
                const radius = Math.min(width, height) * 0.4;
                // Add some randomness to prevent perfect circle clustering
                const randomOffset = (Math.random() - 0.5) * 50;
                node.x = width / 2 + (radius + randomOffset) * Math.cos(angle);
                node.y = height / 2 + (radius + randomOffset) * Math.sin(angle);
            });
            
            // Update network statistics in info panel
            const nodeCountElement = document.getElementById('node-count');
            const linkCountElement = document.getElementById('link-count');
            const termCountElement = document.getElementById('term-count');
            
            if (nodeCountElement) nodeCountElement.textContent = nodes.length;
            if (linkCountElement) linkCountElement.textContent = links.length;
            if (termCountElement) termCountElement.textContent = nodes.length;
            
            // Update positions on simulation tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
                
                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });
            
            // Add drag behavior
            node.call(d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended));
            
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            
            console.log('D3.js network visualization created successfully');
            
            // Store D3 elements globally so updateGraphVisibility can access them
            window.d3Elements = { node, link, label, simulation };
            console.log('D3 elements stored globally:', Object.keys(window.d3Elements));
            
            // Show the full graph initially (no filtering)
            console.log('Showing full graph initially...');
            if (window.updateGraphVisibility) {
                window.updateGraphVisibility(null, null); // This will show everything
            }
            
            // Add filter update function
            window.updateGraphVisibility = function(visibleNodes, visibleLinks) {
                console.log('Updating graph visibility:', { visibleNodes: visibleNodes.length, visibleLinks: visibleLinks.length });
                
                // Special case: if both parameters are null, show everything (reset state)
                if (visibleNodes === null && visibleLinks === null) {
                    console.log('Reset state - showing all nodes and links');
                    node.style('display', 'block');
                    link.style('display', 'block');
                    label.style('display', 'block');
                    
                    // Update statistics to show total counts
                    const nodeCountElement = document.getElementById('node-count');
                    const linkCountElement = document.getElementById('link-count');
                    const termCountElement = document.getElementById('term-count');
                    
                    if (nodeCountElement) nodeCountElement.textContent = window.currentNodes.length;
                    if (linkCountElement) nodeCountElement.textContent = window.currentLinks.length;
                    if (termCountElement) termCountElement.textContent = window.currentNodes.length;
                    return;
                }
                
                // If no visible nodes or links provided, hide everything (filters too restrictive)
                if (!visibleNodes || visibleNodes.length === 0 || !visibleLinks || visibleLinks.length === 0) {
                    console.log('No nodes/links match current filters - hiding everything');
                    node.style('display', 'none');
                    link.style('display', 'none');
                    label.style('display', 'none');
                    
                    // Update statistics to show total counts
                    const nodeCountElement = document.getElementById('node-count');
                    const linkCountElement = document.getElementById('link-count');
                    const termCountElement = document.getElementById('term-count');
                    
                    if (nodeCountElement) nodeCountElement.textContent = '0';
                    if (linkCountElement) linkCountElement.textContent = '0';
                    if (termCountElement) termCountElement.textContent = '0';
                    return;
                }
                
                const nodeIds = new Set(visibleNodes.map(n => n.id));
                const visibleLinkIds = new Set();
                
                // Build set of visible link IDs
                visibleLinks.forEach(l => {
                    const sourceId = l.source.id || l.source;
                    const targetId = l.target.id || l.target;
                    visibleLinkIds.add(`${sourceId}-${targetId}`);
                });
                
                // Update node visibility - completely hide/show nodes
                node.style('display', d => nodeIds.has(d.id) ? 'block' : 'none');
                
                // Update link visibility - completely hide/show links
                link.style('display', d => {
                    const sourceId = d.source.id || d.source;
                    const targetId = d.target.id || d.target;
                    const linkId = `${sourceId}-${targetId}`;
                    return visibleLinkIds.has(linkId) ? 'block' : 'none';
                });
                
                // Update label visibility - completely hide/show labels
                label.style('display', d => nodeIds.has(d.id) ? 'block' : 'none');
                
                // Update statistics
                const nodeCountElement = document.getElementById('node-count');
                const linkCountElement = document.getElementById('link-count');
                const termCountElement = document.getElementById('term-count');
                
                if (nodeCountElement) nodeCountElement.textContent = visibleNodes.length;
                if (linkCountElement) linkCountElement.textContent = visibleLinks.length;
                if (termCountElement) termCountElement.textContent = visibleNodes.length;
            };
        }
        
        // Fallback visualization if D3.js fails
        function createFallbackVisualization(data, container, infoPanel) {
            console.log('Creating fallback visualization...');
            
            container.innerHTML = `
                <div style="padding: 20px; text-align: center;">
                    <h3 style="color: #333; margin-bottom: 20px;">Co-occurrence Network</h3>
                    <p style="color: #666; margin-bottom: 30px;">Interactive network visualization is loading...</p>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        ${Object.entries(data).map(([term, connections]) => `
                            <div style="background: linear-gradient(135deg, ${getNodeColor(Object.keys(connections).length)} 0%, ${getNodeColor(Object.keys(connections).length)}dd 100%); 
                                        color: white; padding: 20px; border-radius: 15px; text-align: center; cursor: pointer;"
                                 onclick="showNodeDetails({id: '${term}', name: '${term}', connections: ${Object.keys(connections).length}, totalWeight: ${Object.values(connections).reduce((a, b) => a + b, 0)}}, document.getElementById('info-panel'))">
                                <div style="font-size: 1.2em; font-weight: bold; margin-bottom: 8px;">${term}</div>
                                <div style="font-size: 0.9em; opacity: 0.9;">${Object.keys(connections).length} connections</div>
                                <div style="font-size: 0.8em; opacity: 0.8; margin-top: 5px;">Weight: ${Object.values(connections).reduce((a, b) => a + b, 0)}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }
        
        // Get node color - consistent purple for all nodes
        function getNodeColor(connections) {
            console.log(`Node with ${connections} connections getting purple color`);
            return '#9b59b6';  // Purple for all nodes regardless of connections
        }
        
        // Show node information on hover
        function showNodeInfo(node, infoPanel) {
            infoPanel.innerHTML = `
                <h4 style="margin: 0 0 10px 0; color: #333;">${node.name}</h4>
                <p style="margin: 5px 0; color: #666;">
                    <strong>Connections:</strong> ${node.connections}
                </p>
                <p style="margin: 5px 0; color: #666;">
                    <strong>Total Weight:</strong> ${node.totalWeight}
                </p>
                <p style="margin: 10px 0 0 0; font-size: 0.9em; color: #999;">
                    Click for more details
                </p>
            `;
            infoPanel.style.display = 'block';
        }
        
        // Show detailed node information on click
        function showNodeDetails(node, infoPanel) {
            console.log('showNodeDetails called for node:', node.name);
            
            // Get related reviews and images - restore working functionality
            let reviews = [];
            let keywordSentenceMap = {};
            let keywordImageMap = {};
            
            // Load data from template variables with more robust error handling
            try {
                console.log('Raw template data - reviews length:', '{{ reviews|tojson|safe }}'.length);
                console.log('Raw template data - sentence map length:', '{{ keyword_sentence_map|tojson|safe }}'.length);
                console.log('Raw template data - image map length:', '{{ keyword_image_map|tojson|safe }}'.length);
                
                // Try parsing with error recovery
                const rawReviews = '{{ reviews|tojson|safe }}';
                const rawSentenceMap = '{{ keyword_sentence_map|tojson|safe }}';
                const rawImageMap = '{{ keyword_image_map|tojson|safe }}';
                
                console.log('Raw sentence map starts with:', rawSentenceMap.substring(0, 100));
                console.log('Raw image map starts with:', rawImageMap.substring(0, 100));
                
                // Parse with error recovery
                try {
                    reviews = JSON.parse(rawReviews);
                } catch (e) {
                    console.error('Failed to parse reviews:', e.message);
                    reviews = [];
                }
                
                try {
                    keywordSentenceMap = JSON.parse(rawSentenceMap);
                } catch (e) {
                    console.error('Failed to parse sentence map:', e.message);
                    console.error('Error at position:', e.message.match(/position (\d+)/)?.[1] || 'unknown');
                    // Try to extract what we can
                    keywordSentenceMap = {};
                    try {
                        // Look for simple key-value pairs
                        const matches = rawSentenceMap.match(/"([^"]+)":\s*\[([^\]]+)\]/g);
                        if (matches) {
                            matches.forEach(match => {
                                const keyMatch = match.match(/"([^"]+)":/);
                                if (keyMatch) {
                                    keywordSentenceMap[keyMatch[1]] = [];
                                }
                            });
                        }
                    } catch (extractError) {
                        console.error('Failed to extract partial data:', extractError.message);
                    }
                }
                
                try {
                    keywordImageMap = JSON.parse(rawImageMap);
                } catch (e) {
                    console.error('Failed to parse image map:', e.message);
                    keywordImageMap = {};
                }
                
                console.log('Successfully loaded data - reviews:', reviews.length, 'sentence map keys:', Object.keys(keywordSentenceMap).length);
            } catch (error) {
                console.error('Error loading data:', error);
                console.error('Error details:', error.message);
                // Fallback to empty data
                reviews = [];
                keywordSentenceMap = {};
                keywordImageMap = {};
            }
            
            // Force display the info panel first
            infoPanel.style.display = 'block';
            infoPanel.style.visibility = 'visible';
            infoPanel.style.opacity = '1';
            infoPanel.innerHTML = '<p>Loading...</p>';
            
            // Debug: Check if info panel is visible
            console.log('Info panel display style:', infoPanel.style.display);
            console.log('Info panel visibility:', infoPanel.style.visibility);
            console.log('Info panel opacity:', infoPanel.style.opacity);
            console.log('Info panel offsetHeight:', infoPanel.offsetHeight);
            console.log('Info panel offsetWidth:', infoPanel.offsetWidth);
            
            console.log('=== DEBUGGING RELATED CONTENT ===');
            console.log('Raw keyword sentence map:', keywordSentenceMap);
            console.log('Raw keyword image map:', keywordImageMap);
            console.log('Keyword sentence map keys:', Object.keys(keywordSentenceMap));
            console.log('Keyword image map keys:', Object.keys(keywordImageMap));
            console.log('Node name being searched:', node.name);
            console.log('Node name type:', typeof node.name);
            console.log('Node name in sentence map?', node.name in keywordSentenceMap);
            console.log('Node name in image map?', node.name in keywordImageMap);
            
            // Check for case variations
            console.log('Checking case variations...');
            const lowerCaseName = node.name.toLowerCase();
            console.log('Lowercase name:', lowerCaseName);
            console.log('Lowercase name in sentence map?', lowerCaseName in keywordSentenceMap);
            
            // Check for partial matches
            const matchingKeys = Object.keys(keywordSentenceMap).filter(key => 
                key.toLowerCase() === lowerCaseName
            );
            console.log('Matching keys (case-insensitive):', matchingKeys);
            
            // Get related reviews using keyword sentence map (try different case variations)
            let relatedReviews = keywordSentenceMap[node.name] || [];
            if (relatedReviews.length === 0) {
                // Try lowercase
                relatedReviews = keywordSentenceMap[node.name.toLowerCase()] || [];
            }
            if (relatedReviews.length === 0) {
                // Try to find by partial match
                const matchingKey = Object.keys(keywordSentenceMap).find(key => 
                    key.toLowerCase() === node.name.toLowerCase()
                );
                if (matchingKey) {
                    relatedReviews = keywordSentenceMap[matchingKey] || [];
                }
            }
            
            // Extract full review information from the dictionary structure
            let relatedReviewsData = [];
            if (relatedReviews.length > 0) {
                if (typeof relatedReviews[0] === 'object' && relatedReviews[0].sentence) {
                    // Extract full review data from dictionary structure
                    relatedReviewsData = relatedReviews.map(item => ({
                        sentence: item.sentence,
                        review_text: item.review_text,
                        review_title: item.review_title,
                        review_index: item.review_index
                    }));
                } else {
                    // Fallback: if it's already in string format, create basic structure
                    relatedReviewsData = relatedReviews.map((text, index) => ({
                        sentence: text,
                        review_text: text,
                        review_title: '',
                        review_index: index
                    }));
                }
            }
            
            // Get related images using keyword image map (try different case variations)
            let relatedImages = keywordImageMap[node.name] || [];
            if (relatedImages.length === 0) {
                // Try lowercase
                relatedImages = keywordImageMap[node.name.toLowerCase()] || [];
            }
            if (relatedImages.length === 0) {
                // Try to find by partial match
                const matchingKey = Object.keys(keywordImageMap).find(key => 
                    key.toLowerCase() === node.name.toLowerCase()
                );
                if (matchingKey) {
                    relatedImages = keywordImageMap[matchingKey] || [];
                }
            }
            console.log('Related images for', node.name, ':', relatedImages);
            console.log('Related images length for', node.name, ':', relatedImages.length);
            
            // Add a simple test to verify the function is working
            console.log('=== FUNCTION WORKING TEST ===');
            console.log('Info panel element:', infoPanel);
            console.log('Info panel display style:', infoPanel.style.display);
            
            // Convert related images to the expected format
            const formattedImages = relatedImages.map(imgUrl => ({
                url: imgUrl,
                reviewer: 'Reviewer', // We don't have individual reviewer info for images
                review_text: 'Related image'
            }));
            
            // Use the full review data from keyword sentence map
            let reviewsContainingKeyword = [];
            const keyword = node.name.toLowerCase(); // Define keyword variable
            
            if (relatedReviewsData.length > 0) {
                // Use the data from keyword sentence map which contains full review info
                reviewsContainingKeyword = relatedReviewsData.map((item, index) => {
                    // Get the original review data using review_index
                    const originalReview = reviews[item.review_index] || {};
                    return {
                        reviewer_name: originalReview.reviewer_name || `Reviewer ${index + 1}`,
                        review_date: originalReview.review_date || 'Date not available',
                        review_rating: originalReview.rating || 'Rating not available',
                        review_text: item.review_text, // Full review text
                        sentence: item.sentence, // The specific sentence containing the keyword
                        review_title: item.review_title || '',
                        review_index: item.review_index
                    };
                });
            } else {
                // Fallback to filtering reviews
                console.log('Falling back to review filtering for:', keyword);
                reviewsContainingKeyword = reviews.filter(review => {
                    const reviewText = (review.review_text || '').toLowerCase();
                    return reviewText.includes(keyword);
                });
            }
            
            console.log('Reviews containing keyword:', reviewsContainingKeyword.length);
            if (reviewsContainingKeyword.length > 0) {
                console.log('Sample review:', reviewsContainingKeyword[0]);
            }
            
            // Store the filtered reviews globally for toggleReviewDisplay to use
            window.currentFilteredReviews = reviewsContainingKeyword;
            
            // Function to find sentence containing keyword
            function findSentenceWithKeyword(text, keyword) {
                if (!text || !keyword) return text;
                const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
                for (let sentence of sentences) {
                    if (sentence.toLowerCase().includes(keyword)) {
                        return sentence.trim() + '.';
                    }
                }
                return text.substring(0, 200) + (text.length > 200 ? '...' : '');
            }
            
            let content = `
                <div style="height: 100%; overflow-y: auto; background: #000000; padding: 20px; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;">
                    <div style="background: #ffffff; color: #000000; padding: 25px; border-radius: 15px; margin-bottom: 25px; box-shadow: 0 8px 32px rgba(255, 255, 255, 0.3); text-align: center;">
                        <h2 style="margin: 0 0 15px 0; font-size: 2.2em; font-weight: 700; text-shadow: 0 2px 4px rgba(0,0,0,0.3);">${node.name.toUpperCase()}</h2>
                        <div style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; gap: 20px;">
                            <div style="text-align: center;">
                                <div style="font-size: 2em; font-weight: bold; margin-bottom: 5px; color: #000000;">${node.connections}</div>
                                <div style="font-size: 0.9em; opacity: 0.9; color: #000000;">Connections</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 2em; font-weight: bold; margin-bottom: 5px; color: #000000;">${node.totalWeight}</div>
                                <div style="font-size: 0.9em; opacity: 0.9; color: #000000;">Total Weight</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 2em; font-weight: bold; margin-bottom: 5px; color: #000000;">${reviewsContainingKeyword.length}</div>
                                <div style="font-size: 0.9em; opacity: 0.9; color: #000000;">Reviews Found</div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="background: #000000; padding: 20px; border-radius: 15px; margin-bottom: 25px; box-shadow: 0 4px 20px rgba(255,255,255,0.1); border: 1px solid #ffffff;">
                        <h3 style="margin: 0 0 20px 0; color: #ffffff; display: flex; align-items: center; font-size: 1.4em; font-weight: 600;">
                            <span style="background: #ffffff; color: #000000; padding: 8px 12px; border-radius: 8px; font-size: 0.9em; margin-right: 12px; box-shadow: 0 2px 8px rgba(255, 255, 255, 0.3);">${reviewsContainingKeyword.length}</span>
                            Reviews Containing "${node.name}"
                        </h3>
            `;
            
            if (reviewsContainingKeyword.length > 0) {
                            // Store current keyword and reviews globally for pagination
            window.currentKeyword = keyword;
            window.allReviews = reviewsContainingKeyword;
            window.currentFilteredReviews = reviewsContainingKeyword;
            window.currentReviewPage = 1;
            window.reviewsPerPage = 5;
            
            // Calculate pagination
            const totalReviewPages = Math.ceil(reviewsContainingKeyword.length / window.reviewsPerPage);
            const startIndex = 0;
            const endIndex = Math.min(window.reviewsPerPage, reviewsContainingKeyword.length);
            
            // Display first page of reviews
            content += `<div class="reviews-section">`;
            reviewsContainingKeyword.slice(startIndex, endIndex).forEach((review, displayIndex) => {
                const actualIndex = startIndex + displayIndex; // Calculate the actual index in the full reviews array
                const sentenceWithKeyword = findSentenceWithKeyword(review.review_text, keyword);
                const highlightedSentence = highlightKeyword(sentenceWithKeyword, keyword);
                
                content += `
                    <div id="review-${displayIndex}" style="margin-bottom: 25px; background: #000000; border-radius: 12px; box-shadow: 0 4px 20px rgba(255,255,255,0.08); overflow: hidden; transition: all 0.3s ease; border: 1px solid #ffffff;">
                        <div style="background: #ffffff; color: #000000; padding: 15px;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="font-weight: 600; font-size: 1.1em; color: #000000;">${review.reviewer_name || review.reviewer || 'Anonymous'}</div>
                                <div style="font-size: 0.9em; opacity: 0.9; color: #000000;">${formatDate(review.review_date || review.date || 'Unknown date')}</div>
                            </div>
                        </div>
                        
                        <div id="sentence-${displayIndex}" style="padding: 20px; background: #000000;">
                            <!-- Show rating if available -->
                            ${review.review_rating && review.review_rating !== 'Rating not available' ? `
                                <div style="margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                                    <div style="display: flex; align-items: center;">
                                        ${generateStarRating(review.review_rating)}
                                    </div>
                                    <span style="font-size: 0.9em; color: #ffffff; font-weight: 500;">
                                        ${typeof review.review_rating === 'number' ? `${review.review_rating}/5 stars` : review.review_rating}
                                    </span>
                                </div>
                            ` : ''}
                            
                            <!-- Show review title if available -->
                            ${review.review_title ? `
                                <div style="margin-bottom: 15px; background: #ffffff; padding: 12px; border-radius: 8px; border-left: 4px solid #ffffff;">
                                    <h4 style="margin: 0; color: #000000; font-size: 1.1em; font-weight: 600;">${review.review_title}</h4>
                                </div>
                            ` : ''}
                            
                            <!-- Show the sentence containing the keyword -->
                            <p style="margin: 0 0 15px 0; font-size: 1em; color: #ffffff; line-height: 1.6; font-style: italic; background: #333333; padding: 15px; border-radius: 8px; border-left: 4px solid #ffffff;">
                                <strong>Sentence with "${node.name}":</strong><br>
                                ${highlightedSentence}
                            </p>
                            
                            <button class="show-full-btn" onclick="toggleReviewDisplay(${actualIndex}, '${keyword}')" 
                                    style="background: #ffffff; color: #000000; border: none; padding: 10px 20px; border-radius: 8px; font-size: 0.9em; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 2px 8px rgba(255, 255, 255, 0.3); font-weight: 500;">
                                Show Full Review
                            </button>
                        </div>
                        
                        <div id="full-review-${displayIndex}" style="display: none; margin: 0 20px 20px 20px; background: #000000; border-radius: 8px; box-shadow: 0 2px 10px rgba(255,255,255,0.1); overflow: hidden; border: 1px solid #ffffff;">
                            <!-- Full review content will be loaded here -->
                        </div>
                    </div>
                `;
            });
            
            // Add review pagination controls
            if (totalReviewPages > 1) {
                content += `
                    <div id="review-pagination" style="text-align: center; margin: 25px 0; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 15px; box-shadow: 0 4px 20px rgba(102, 126, 234, 0.3); color: white;">
                        <div style="margin-bottom: 15px; font-size: 1em; font-weight: 500; opacity: 0.9;">
                            Showing ${startIndex + 1}-${endIndex} of ${reviewsContainingKeyword.length} reviews
                        </div>
                        <div style="display: flex; justify-content: center; gap: 15px; align-items: center;">
                            <button onclick="changeReviewPage(${totalReviewPages}, -1)" 
                                    style="background: rgba(255,255,255,0.2); color: white; border: 2px solid rgba(255,255,255,0.3); padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 0.9em; font-weight: 500; transition: all 0.3s ease; backdrop-filter: blur(10px);">
                                ‚Üê Previous
                            </button>
                            <span style="font-size: 1em; font-weight: 600; background: rgba(255,255,255,0.2); padding: 8px 16px; border-radius: 8px; backdrop-filter: blur(10px);">
                                Page ${window.currentReviewPage} of ${totalReviewPages}
                            </span>
                            <button onclick="changeReviewPage(${totalReviewPages}, 1)" 
                                    style="background: rgba(255,255,255,0.2); color: white; border: 2px solid rgba(255,255,255,0.3); padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 0.9em; font-weight: 500; transition: all 0.3s ease; backdrop-filter: blur(10px);">
                                Next ‚Üí
                            </button>
                        </div>
                    </div>
                `;
            } else if (reviewsContainingKeyword.length > 5) {
                content += `<p style="font-size: 0.8em; color: #999; text-align: center; margin: 10px 0;">Showing all ${reviewsContainingKeyword.length} reviews</p>`;
            }
            }
            content += `</div>`; // Close reviews-section
            
            if (reviewsContainingKeyword.length === 0) {
                content += `<p style="font-size: 0.9em; color: #999; font-style: italic;">No reviews found containing "${node.name}"</p>`;
            }
            
            // Add related images section
            content += `
                </div>
                <div style="background: white; padding: 20px; border-radius: 15px; margin-bottom: 25px; box-shadow: 0 4px 20px rgba(0,0,0,0.1);">
                    <h3 style="margin: 0 0 20px 0; color: #333; display: flex; align-items: center; font-size: 1.4em; font-weight: 600;">
                        <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 8px 12px; border-radius: 8px; font-size: 0.9em; margin-right: 12px; box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);">${formattedImages.length}</span>
                        Related Images
                    </h3>
            `;
            
            if (formattedImages.length > 0) {
                // Store images globally for pagination
                window.allImages = formattedImages;
                window.currentImagePage = 1;
                window.imagesPerPage = 6;
                
                // Calculate image pagination
                const totalImagePages = Math.ceil(formattedImages.length / window.imagesPerPage);
                const imageStartIndex = 0;
                const imageEndIndex = Math.min(window.imagesPerPage, formattedImages.length);
                
                content += `<div id="images-container" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 15px; margin-top: 15px;">`;
                
                formattedImages.slice(imageStartIndex, imageEndIndex).forEach((imgData, index) => {
                    content += `
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); transition: all 0.3s ease; border: 1px solid #e8e8e8;">
                            <img src="${imgData.url}" alt="Related image" 
                                 style="width: 100%; height: 100px; object-fit: cover; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 2px 8px rgba(0,0,0,0.1);"
                                 onclick="openImageModal('${imgData.url}', '${imgData.reviewer}', '${imgData.review_text.replace(/'/g, "\\'")}')"
                                 onerror="this.style.display='none'"
                                 onmouseover="this.style.transform='scale(1.05)'"
                                 onmouseout="this.style.transform='scale(1)'">
                            <p style="font-size: 0.8em; color: #666; margin: 8px 0 0 0; font-weight: 500;">${imgData.reviewer}</p>
                        </div>
                    `;
                });
                
                content += `</div>`;
                
                // Add image pagination controls
                if (totalImagePages > 1) {
                    content += `
                        <div id="image-pagination" style="text-align: center; margin: 25px 0; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 15px; box-shadow: 0 4px 20px rgba(102, 126, 234, 0.3); color: white;">
                            <div style="margin-bottom: 15px; font-size: 1em; font-weight: 500; opacity: 0.9;">
                                Showing ${imageStartIndex + 1}-${imageEndIndex} of ${formattedImages.length} images
                            </div>
                            <div style="display: flex; justify-content: center; gap: 15px; align-items: center;">
                                <button onclick="changeImagePage(${totalImagePages}, -1)" 
                                        style="background: rgba(255,255,255,0.2); color: white; border: 2px solid rgba(255,255,255,0.3); padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 0.9em; font-weight: 500; transition: all 0.3s ease; backdrop-filter: blur(10px);">
                                    ‚Üê Previous
                                </button>
                                <span style="font-size: 1em; font-weight: 600; background: rgba(255,255,255,0.2); padding: 8px 16px; border-radius: 8px; backdrop-filter: blur(10px);">
                                    Page ${window.currentImagePage} of ${totalImagePages}
                                </span>
                                <button onclick="changeImagePage(${totalImagePages}, 1)" 
                                        style="background: rgba(255,255,255,0.2); color: white; border: 2px solid rgba(255,255,255,0.3); padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 0.9em; font-weight: 500; transition: all 0.3s ease; backdrop-filter: blur(10px);">
                                    Next ‚Üí
                                </button>
                            </div>
                        </div>
                    `;
                } else if (formattedImages.length > 6) {
                    content += `<p style="font-size: 0.9em; color: #666; text-align: center; margin: 15px 0; font-weight: 500;">Showing all ${formattedImages.length} images</p>`;
                }
            } else {
                content += `<p style="font-size: 0.9em; color: #999; font-style: italic;">No related images found</p>`;
            }
            
            content += `</div>`;
            
            console.log('Generated content length:', content.length);
            console.log('Generated content preview:', content.substring(0, 200) + '...');
            
            infoPanel.innerHTML = content;
            infoPanel.style.display = 'block';
            infoPanel.style.visibility = 'visible';
            infoPanel.style.opacity = '1';
            
            // Force a reflow to ensure the content is displayed
            infoPanel.offsetHeight;
            
            console.log('Final info panel innerHTML length:', infoPanel.innerHTML.length);
            console.log('Final info panel display style:', infoPanel.style.display);
        }
        
        // Function to toggle review display (show/hide full review)
        function toggleReviewDisplay(index, keyword) {
            // Find the display index for the current page
            const currentPage = window.currentReviewPage || 1;
            const reviewsPerPage = window.reviewsPerPage || 5;
            const startIndex = (currentPage - 1) * reviewsPerPage;
            const displayIndex = index - startIndex;
            
            console.log('Toggle review display - index:', index, 'displayIndex:', displayIndex, 'currentPage:', currentPage);
            
            const fullReviewDiv = document.getElementById(`full-review-${displayIndex}`);
            const button = document.querySelector(`#review-${displayIndex} .show-full-btn`);
            
            if (fullReviewDiv.style.display === 'none') {
                // Show full review - get data from the filtered reviews array
                const filteredReviews = window.currentFilteredReviews || [];
                if (filteredReviews.length === 0) {
                    console.error('No filtered reviews available');
                    return;
                }
                
                const currentKeyword = keyword || window.currentKeyword || '';
                const review = filteredReviews[index];
                
                console.log('Toggle review display - review data:', review);
                console.log('Review text length:', review?.review_text?.length || 0);
                console.log('Reviewer name:', review?.reviewer_name || review?.reviewer || 'Not found');
                console.log('Review date:', review?.review_date || review?.date || 'Not found');
                console.log('Review rating:', review?.rating || review?.star_rating || 'Not found');
                
                if (review && review.review_text) {
                    const highlightedFullReview = highlightKeyword(review.review_text, currentKeyword);
                    
                    // Generate star rating HTML
                    const starRating = review.star_rating || review.rating || null;
                    const starsHTML = generateStarRating(starRating);
                    
                    // Extract numeric rating for display
                    let numericRating = null;
                    if (starRating) {
                        if (typeof starRating === 'string') {
                            const match = starRating.match(/(\d+(?:\.\d+)?)/);
                            if (match) {
                                numericRating = parseFloat(match[1]);
                            }
                        } else if (typeof starRating === 'number') {
                            numericRating = starRating;
                        }
                    }
                    
                    // Format date
                    const reviewDate = review.review_date || review.date || 'Unknown date';
                    const formattedDate = formatDate(reviewDate);
                    
                    fullReviewDiv.innerHTML = `
                        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 15px; border-radius: 8px 8px 0 0; margin: -10px -10px 15px -10px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <div style="font-weight: bold; font-size: 1.1em;">${review.reviewer_name || review.reviewer || 'Anonymous'}</div>
                                <div style="font-size: 0.9em; opacity: 0.9;">${formattedDate}</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <div style="display: flex; align-items: center;">
                                    ${starsHTML}
                                </div>
                                ${numericRating && !isNaN(numericRating) && numericRating >= 0 && numericRating <= 5 ? 
                                    `<span style="font-size: 0.9em; opacity: 0.9;">${numericRating}/5 stars</span>` : 
                                    `<span style="font-size: 0.9em; opacity: 0.9; font-style: italic;">Rating not available</span>`
                                }
                            </div>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #667eea;">
                            <p style="margin: 0; font-size: 0.95em; color: #333; line-height: 1.6; white-space: pre-wrap; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;">${highlightedFullReview}</p>
                        </div>
                        <button onclick="toggleReviewDisplay(${index})" 
                                style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 8px 16px; border-radius: 6px; font-size: 0.9em; cursor: pointer; margin-top: 15px; transition: all 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                            Show Less
                        </button>
                    `;
                    fullReviewDiv.style.display = 'block';
                    if (button) button.textContent = 'Show Less';
                }
            } else {
                // Hide full review
                fullReviewDiv.style.display = 'none';
                if (button) button.textContent = 'Show Full Review';
            }
        }
        
        // Function to highlight keyword in text
        function highlightKeyword(text, keyword) {
            if (!text || !keyword) return text;
            const regex = new RegExp(`(${keyword})`, 'gi');
            return text.replace(regex, '<mark style="background-color: #ffeb3b; padding: 2px 4px; border-radius: 3px; font-weight: bold;">$1</mark>');
        }
        
        // Function to open image modal
        function openImageModal(imageUrl, reviewer, reviewText) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.9);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 20000;
            `;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                border-radius: 15px;
                padding: 20px;
                max-width: 90%;
                max-height: 90%;
                text-align: center;
            `;
            
            modalContent.innerHTML = `
                <button onclick="this.parentElement.parentElement.remove()" 
                        style="position: absolute; top: 10px; right: 15px; background: none; border: none; font-size: 24px; cursor: pointer; color: #666;">&times;</button>
                <h4 style="margin: 0 0 15px 0; color: #333;">Related Image</h4>
                <img src="${imageUrl}" alt="Review image" style="max-width: 100%; max-height: 60vh; border-radius: 8px;">
                <p style="margin: 10px 0 0 0; font-size: 0.9em; color: #666;"><strong>By:</strong> ${reviewer}</p>
                <p style="margin: 5px 0 0 0; font-size: 0.8em; color: #999;">${reviewText}</p>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
        }
        
        // Function to change review page
        function changeReviewPage(totalPages, direction) {
            const newPage = window.currentReviewPage + direction;
            if (newPage < 1 || newPage > totalPages) return;
            
            window.currentReviewPage = newPage;
            const startIndex = (newPage - 1) * window.reviewsPerPage;
            const endIndex = Math.min(startIndex + window.reviewsPerPage, window.allReviews.length);
            
            console.log('Changing to page:', newPage, 'startIndex:', startIndex, 'endIndex:', endIndex);
            
            // Find the reviews container
            const reviewsContainer = document.querySelector('#info-panel');
            if (!reviewsContainer) {
                console.error('Reviews container not found');
                return;
            }
            
            // Find the reviews section and pagination section to replace
            const reviewsSection = reviewsContainer.querySelector('.reviews-section');
            const paginationSection = reviewsContainer.querySelector('#review-pagination');
            
            console.log('Found reviews section:', reviewsSection);
            console.log('Found pagination section:', paginationSection);
            
            if (!reviewsSection) {
                console.error('Reviews section not found');
                return;
            }
            
            // Generate new reviews content
            let newReviewsContent = '';
            window.allReviews.slice(startIndex, endIndex).forEach((review, index) => {
                const displayIndex = index; // Use display index for this page
                const globalIndex = startIndex + index;
                const sentenceWithKeyword = findSentenceWithKeyword(review.review_text, window.currentKeyword);
                const highlightedSentence = highlightKeyword(sentenceWithKeyword, window.currentKeyword);
                
                newReviewsContent += `
                    <div id="review-${displayIndex}" style="margin-bottom: 25px; background: white; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); overflow: hidden; transition: all 0.3s ease; border: 1px solid #e8e8e8;">
                        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 15px;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="font-weight: 600; font-size: 1.1em;">${review.reviewer_name || review.reviewer || 'Anonymous'}</div>
                                <div style="font-size: 0.9em; opacity: 0.9;">${formatDate(review.review_date || review.date || 'Unknown date')}</div>
                            </div>
                        </div>
                        
                        <div id="sentence-${displayIndex}" style="padding: 20px;">
                            <!-- Show rating if available -->
                            ${review.review_rating && review.review_rating !== 'Rating not available' ? `
                                <div style="margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                                    <div style="display: flex; align-items: center;">
                                        ${generateStarRating(review.review_rating)}
                                    </div>
                                    <span style="font-size: 0.9em; color: #666; font-weight: 500;">
                                        ${typeof review.review_rating === 'number' ? `${review.review_rating}/5 stars` : review.review_rating}
                                    </span>
                                </div>
                            ` : ''}
                            
                            <!-- Show review title if available -->
                            ${review.review_title ? `
                                <div style="margin-bottom: 15px; background: #e3f2fd; padding: 12px; border-radius: 8px; border-left: 4px solid #2196f3;">
                                    <h4 style="margin: 0; color: #1976d2; font-size: 1.1em; font-weight: 600;">${review.review_title}</h4>
                                </div>
                            ` : ''}
                            
                            <!-- Show the sentence containing the keyword -->
                            <p style="margin: 0 0 15px 0; font-size: 1em; color: #333; line-height: 1.6; font-style: italic; background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #667eea;">
                                <strong>Sentence with "${window.currentKeyword}":</strong><br>
                                ${highlightedSentence}
                            </p>
                            
                            <button class="show-full-btn" onclick="toggleReviewDisplay(${globalIndex}, '${window.currentKeyword}')" 
                                    style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 10px 20px; border-radius: 8px; font-size: 0.9em; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3); font-weight: 500;">
                                Show Full Review
                            </button>
                        </div>
                        
                        <div id="full-review-${displayIndex}" style="display: none; margin: 0 20px 20px 20px; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); overflow: hidden;">
                            <!-- Full review content will be loaded here -->
                        </div>
                    </div>
                `;
            });
            
            // Update pagination controls
            const paginationContent = `
                <div id="review-pagination" style="text-align: center; margin: 25px 0; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 15px; box-shadow: 0 4px 20px rgba(102, 126, 234, 0.3); color: white;">
                    <div style="margin-bottom: 15px; font-size: 1em; font-weight: 500; opacity: 0.9;">
                        Showing ${startIndex + 1}-${endIndex} of ${window.allReviews.length} reviews
                    </div>
                    <div style="display: flex; justify-content: center; gap: 15px; align-items: center;">
                        <button onclick="changeReviewPage(${totalPages}, -1)" 
                                style="background: rgba(255,255,255,0.2); color: white; border: 2px solid rgba(255,255,255,0.3); padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 0.9em; font-weight: 500; transition: all 0.3s ease; backdrop-filter: blur(10px);">
                            ‚Üê Previous
                        </button>
                        <span style="font-size: 1em; font-weight: 600; background: rgba(255,255,255,0.2); padding: 8px 16px; border-radius: 8px; backdrop-filter: blur(10px);">
                            Page ${window.currentReviewPage} of ${totalPages}
                        </span>
                        <button onclick="changeReviewPage(${totalPages}, 1)" 
                                style="background: rgba(255,255,255,0.2); color: white; border: 2px solid rgba(255,255,255,0.3); padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 0.9em; font-weight: 500; transition: all 0.3s ease; backdrop-filter: blur(10px);">
                            Next ‚Üí
                        </button>
                    </div>
                </div>
            `;
            
            // Replace the reviews section content
            reviewsSection.innerHTML = newReviewsContent;
            
            // Find and replace the pagination section
            const existingPagination = reviewsContainer.querySelector('#review-pagination');
            if (existingPagination) {
                existingPagination.outerHTML = paginationContent;
                console.log('Pagination section replaced');
            } else {
                // If pagination section doesn't exist, add it after the reviews section
                reviewsSection.insertAdjacentHTML('afterend', paginationContent);
                console.log('Pagination section added');
            }
            
            // Verify pagination section exists after update
            const updatedPagination = reviewsContainer.querySelector('#review-pagination');
            if (updatedPagination) {
                console.log('Pagination section verified after update');
            } else {
                console.error('Pagination section still missing after update');
            }
            
            console.log('Page change completed successfully');
        }
        
        // Function to change image page
        function changeImagePage(totalPages, direction) {
            const newPage = window.currentImagePage + direction;
            if (newPage < 1 || newPage > totalPages) return;
            
            window.currentImagePage = newPage;
            const startIndex = (newPage - 1) * window.imagesPerPage;
            const endIndex = Math.min(startIndex + window.imagesPerPage, window.allImages.length);
            
            // Find the images container and replace content
            const imagesContainer = document.getElementById('images-container');
            const paginationContainer = document.getElementById('image-pagination');
            
            if (!imagesContainer) return;
            
            // Generate new images content
            let newImagesContent = '';
            window.allImages.slice(startIndex, endIndex).forEach((imgData, index) => {
                newImagesContent += `
                    <div style="text-align: center;">
                        <img src="${imgData.url}" alt="Related image" 
                             style="width: 100%; height: 80px; object-fit: cover; border-radius: 8px; border: 2px solid #eee; cursor: pointer;"
                             onclick="openImageModal('${imgData.url}', '${imgData.reviewer}', '${imgData.review_text.replace(/'/g, "\\'")}')"
                             onerror="this.style.display='none'">
                        <p style="font-size: 0.7em; color: #666; margin: 5px 0 0 0;">${imgData.reviewer}</p>
                    </div>
                `;
            });
            
            imagesContainer.innerHTML = newImagesContent;
            
            // Update pagination controls
            if (paginationContainer) {
                paginationContainer.innerHTML = `
                    <div style="margin-bottom: 10px; font-size: 0.9em; color: #666;">
                        Showing ${startIndex + 1}-${endIndex} of ${window.allImages.length} images
                    </div>
                    <div style="display: flex; justify-content: center; gap: 10px; align-items: center;">
                        <button onclick="changeImagePage(${totalPages}, -1)" 
                                style="background: #667eea; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 0.8em;">
                            Previous
                        </button>
                        <span style="font-size: 0.9em; color: #333;">
                            Page ${window.currentImagePage} of ${totalPages}
                        </span>
                        <button onclick="changeImagePage(${totalPages}, 1)" 
                                style="background: #667eea; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 0.8em;">
                            Next
                        </button>
                    </div>
                `;
            }
        }
        
        // Helper function to find sentence with keyword (needed for pagination)
        function findSentenceWithKeyword(text, keyword) {
            if (!text || !keyword) return text;
            const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
            for (let sentence of sentences) {
                if (sentence.toLowerCase().includes(keyword)) {
                    return sentence.trim() + '.';
                }
            }
            return text.substring(0, 200) + (text.length > 200 ? '...' : '');
        }
        
        // Function to generate star rating HTML
        function generateStarRating(rating) {
            // Parse rating from different formats
            let numericRating = 0;
            
            if (rating) {
                if (typeof rating === 'string') {
                    // Handle formats like "5 out of 5", "4.5", "3 stars", etc.
                    const match = rating.match(/(\d+(?:\.\d+)?)/);
                    if (match) {
                        numericRating = parseFloat(match[1]);
                    }
                } else if (typeof rating === 'number') {
                    numericRating = rating;
                }
            }
            
            // Validate rating range
            if (isNaN(numericRating) || numericRating < 0 || numericRating > 5) {
                return '<span style="color: #999; font-size: 0.9em; font-style: italic;">No rating available</span>';
            }
            
            const fullStars = Math.floor(numericRating);
            const hasHalfStar = numericRating % 1 !== 0;
            const emptyStars = 5 - fullStars - (hasHalfStar ? 1 : 0);
            
            let starsHTML = '';
            
            // Full stars
            for (let i = 0; i < fullStars; i++) {
                starsHTML += '<span style="color: #ffd700; font-size: 1.2em;">‚òÖ</span>';
            }
            
            // Half star
            if (hasHalfStar) {
                starsHTML += '<span style="color: #ffd700; font-size: 1.2em;">‚òÜ</span>';
            }
            
            // Empty stars
            for (let i = 0; i < emptyStars; i++) {
                starsHTML += '<span style="color: #ddd; font-size: 1.2em;">‚òÜ</span>';
            }
            
            return starsHTML;
        }
        
        // Function to format date
        function formatDate(dateString) {
            if (!dateString || dateString === 'Unknown date' || dateString === '') {
                return 'Date not available';
            }
            
            try {
                const date = new Date(dateString);
                if (isNaN(date.getTime())) {
                    // Try to parse common date formats
                    const dateFormats = [
                        /(\d{1,2})\/(\d{1,2})\/(\d{4})/, // MM/DD/YYYY
                        /(\d{4})-(\d{1,2})-(\d{1,2})/, // YYYY-MM-DD
                        /(\d{1,2})-(\d{1,2})-(\d{4})/, // MM-DD-YYYY
                    ];
                    
                    for (let format of dateFormats) {
                        const match = dateString.match(format);
                        if (match) {
                            const [_, month, day, year] = match;
                            const parsedDate = new Date(year, month - 1, day);
                            if (!isNaN(parsedDate.getTime())) {
                                const options = { 
                                    year: 'numeric', 
                                    month: 'short', 
                                    day: 'numeric'
                                };
                                return parsedDate.toLocaleDateString('en-US', options);
                            }
                        }
                    }
                    
                    // If we can't parse it, return a cleaned version
                    return dateString.replace(/[^\w\s\-]/g, '').trim() || 'Date not available';
                }
                
                const options = { 
                    year: 'numeric', 
                    month: 'short', 
                    day: 'numeric'
                };
                
                return date.toLocaleDateString('en-US', options);
            } catch (error) {
                return 'Date not available';
            }
        }

        // Mark defective parts
        function markDefectiveParts() {
            console.log('markDefectiveParts function called!');
            
            // Test with sample data first
            let defectPairs = [
                ["package", "leak"],
                ["container", "damage"],
                ["bottle", "broken"],
                ["cap", "loose"],
                ["seal", "crack"]
            ];
            
            try {
                console.log('Raw defect pairs:', '{{ defect_pairs|tojson|safe }}');
                const parsedPairs = JSON.parse('{{ defect_pairs|tojson|safe }}');
                console.log('Parsed defect pairs:', parsedPairs);
                
                if (parsedPairs && parsedPairs.length > 0) {
                    defectPairs = parsedPairs;
                }
            } catch (error) {
                console.error('Error parsing defect pairs:', error);
                console.error('Raw data was:', '{{ defect_pairs|tojson|safe }}');
                console.log('Using sample data instead');
            }
            
            console.log('Creating defect modal...');
            // Create modal for defect visualization
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: #000000;
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
            `;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: #000000;
                border-radius: 15px;
                padding: 30px;
                width: 95vw;
                height: 95vh;
                overflow: hidden;
                position: relative;
                display: flex;
                flex-direction: column;
            `;
            
            // Close button
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = '&times;';
            closeBtn.style.cssText = `
                position: absolute;
                top: 15px;
                right: 20px;
                background: none;
                border: none;
                font-size: 24px;
                cursor: pointer;
                color: #ffffff;
                z-index: 1001;
            `;
            closeBtn.onclick = () => document.body.removeChild(modal);
            
            // Title
            const title = document.createElement('h2');
            title.textContent = 'Defect Visualization';
            title.style.cssText = `
                margin: 0 0 20px 0;
                color: #ffffff;
                text-align: center;
                font-size: 1.5em;
            `;
            
            // Main container with integrated layout
            const mainContainer = document.createElement('div');
            mainContainer.style.cssText = `
                flex: 1;
                min-height: 600px;
                background: #000000;
                border-radius: 10px;
                position: relative;
                overflow: hidden;
                display: flex;
            `;
            
            // Left side - Product image
            const imageContainer = document.createElement('div');
            imageContainer.style.cssText = `
                flex: 2;
                position: relative;
                overflow: hidden;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                padding: 20px;
            `;
            
            const defectImageUrl = {{ (defect_overlay_url or '') | tojson }};
            const baseImageUrl = {{ (product_image_url or '') | tojson }};
            
            let productImage;
            if (defectImageUrl && defectImageUrl !== '/static/None/defects_overlay.png') {
                productImage = document.createElement('img');
                productImage.src = defectImageUrl;
                productImage.style.cssText = `
                    max-width: 100%;
                    max-height: 100%;
                    object-fit: contain;
                    border-radius: 8px;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
                `;
            } else if (baseImageUrl && baseImageUrl !== '/static/None/product.jpg') {
                productImage = document.createElement('img');
                productImage.src = baseImageUrl;
                productImage.style.cssText = `
                    max-width: 100%;
                    max-height: 100%;
                    object-fit: contain;
                    border-radius: 8px;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
                    position: relative;
                `;
                
                // Add defect markers as overlay
                defectPairs.forEach((pair, index) => {
                    const marker = document.createElement('div');
                    marker.style.cssText = `
                        position: absolute;
                        top: ${20 + (index * 30)}px;
                        left: ${20 + (index * 20)}px;
                        background: #ff4444;
                        color: white;
                        border-radius: 50%;
                        width: 30px;
                        height: 30px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-weight: bold;
                        font-size: 12px;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                        z-index: 10;
                    `;
                    marker.textContent = index + 1;
                    productImage.appendChild(marker);
                });
            } else {
                // Fallback if no image available
                productImage = document.createElement('div');
                productImage.style.cssText = `
                    width: 100%;
                    height: 100%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    background: #333333;
                    border-radius: 8px;
                    color: #ffffff;
                    font-size: 1.2em;
                `;
                productImage.textContent = 'Product image not available';
            }
            
            imageContainer.appendChild(productImage);
            
            // Right side - Defect pairs panel
            const defectPanel = document.createElement('div');
            defectPanel.style.cssText = `
                flex: 1;
                background: #000000;
                border-left: 2px solid #ffffff;
                padding: 25px;
                max-height: 100%;
                overflow-y: auto;
                display: block;
                box-shadow: -4px 0 15px rgba(255,255,255,0.1);
            `;
            
            // Summary
            const summary = document.createElement('div');
            summary.style.cssText = `
                background: #ffffff;
                border: 1px solid #ffffff;
                border-radius: 8px;
                padding: 15px;
                margin-bottom: 20px;
                text-align: center;
            `;
            summary.innerHTML = `
                <strong style="color: #000000;">${defectPairs.length} defect relationships detected</strong><br>
                <small style="color: #000000;">Component-Condition pairs found in reviews</small>
            `;
            
            // Defect pairs visualization
            const defectContainer = document.createElement('div');
            defectContainer.style.cssText = `
                display: flex;
                flex-direction: column;
                gap: 15px;
            `;
            
            defectPairs.forEach((pair, index) => {
                const defectCard = document.createElement('div');
                defectCard.style.cssText = `
                    background: #ffffff;
                    color: #000000;
                    padding: 20px;
                    border-radius: 12px;
                    text-align: center;
                    box-shadow: 0 4px 8px rgba(255,255,255,0.1);
                    position: relative;
                    border: 1px solid #ffffff;
                `;
                
                const defectNumber = document.createElement('div');
                defectNumber.style.cssText = `
                    position: absolute;
                    top: 10px;
                    right: 15px;
                    background: #000000;
                    color: #ffffff;
                    border-radius: 50%;
                    width: 25px;
                    height: 25px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 0.8em;
                    font-weight: bold;
                `;
                defectNumber.textContent = index + 1;
                
                const component = document.createElement('div');
                component.style.cssText = `
                    font-size: 1.2em;
                    font-weight: bold;
                    margin-bottom: 10px;
                    color: #000000;
                `;
                component.textContent = pair[0];
                
                const arrow = document.createElement('div');
                arrow.style.cssText = `
                    font-size: 1.5em;
                    margin: 10px 0;
                    color: #000000;
                `;
                arrow.textContent = '‚Üì';
                
                const condition = document.createElement('div');
                condition.style.cssText = `
                    font-size: 1.1em;
                    opacity: 0.9;
                    color: #000000;
                `;
                condition.textContent = pair[1];
                
                defectCard.appendChild(defectNumber);
                defectCard.appendChild(component);
                defectCard.appendChild(arrow);
                defectCard.appendChild(condition);
                defectContainer.appendChild(defectCard);
            });
            
            defectPanel.appendChild(summary);
            defectPanel.appendChild(defectContainer);
            
            mainContainer.appendChild(imageContainer);
            mainContainer.appendChild(defectPanel);
            
            modalContent.appendChild(closeBtn);
            modalContent.appendChild(title);
            modalContent.appendChild(mainContainer);
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            console.log('Defect modal added to DOM');
        }

        // Image modal
        function openImageModal(imageUrl) {
            // Create modal for image viewing
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.9);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                cursor: pointer;
            `;
            
            const img = document.createElement('img');
            img.src = imageUrl;
            img.style.cssText = `
                max-width: 90%;
                max-height: 90%;
                object-fit: contain;
                border-radius: 10px;
            `;
            
            modal.appendChild(img);
            document.body.appendChild(modal);
            
            modal.addEventListener('click', () => {
                document.body.removeChild(modal);
            });
        }
        
        // Pagination functionality
        const totalReviews = (window.allReviews?.length) || 0;
        
        // Initialize pagination
        function initializePagination() {
            updatePagination();
        }
        
        // Update pagination
        function updatePagination() {
            const totalPages = Math.ceil(filteredReviews.length / reviewsPerPage);
            
            // Update page numbers display
            const pageNumbersContainer = document.getElementById('page-numbers');
            pageNumbersContainer.innerHTML = '';
            
            const maxVisiblePages = 5;
            let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
            let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
            
            if (endPage - startPage + 1 < maxVisiblePages) {
                startPage = Math.max(1, endPage - maxVisiblePages + 1);
            }
            
            for (let i = startPage; i <= endPage; i++) {
                const pageBtn = document.createElement('button');
                pageBtn.className = `page-number ${i === currentPage ? 'active' : ''}`;
                pageBtn.textContent = i;
                pageBtn.onclick = () => goToPage(i);
                pageNumbersContainer.appendChild(pageBtn);
            }
            
            // Update pagination info
            const start = filteredReviews.length > 0 ? (currentPage - 1) * reviewsPerPage + 1 : 0;
            const end = Math.min(currentPage * reviewsPerPage, filteredReviews.length);
            document.getElementById('current-page-info').textContent = filteredReviews.length > 0 ? `${start}-${end}` : '0-0';
            
            // Update pagination buttons
            document.getElementById('prev-page').disabled = currentPage === 1;
            document.getElementById('next-page').disabled = currentPage === totalPages || totalPages === 0;
        }
        
        // Change page
        function changePage(direction) {
            const totalPages = Math.ceil(filteredReviews.length / reviewsPerPage);
            const newPage = currentPage + direction;
            if (newPage >= 1 && newPage <= totalPages) {
                goToPage(newPage);
            }
        }
        
        // Go to specific page
        function goToPage(page) {
            currentPage = page;
            showCurrentPageReviews();
            updatePagination();
        }
        
        // Show reviews for current page
        function showCurrentPageReviews() {
            // First, hide all review cards
            const allReviewCards = document.querySelectorAll('.review-card');
            allReviewCards.forEach(card => {
                card.style.display = 'none';
            });
            
            // Then show only the filtered reviews for the current page
            const startIndex = (currentPage - 1) * reviewsPerPage;
            const endIndex = startIndex + reviewsPerPage;
            
            filteredReviews.slice(startIndex, endIndex).forEach(card => {
                card.style.display = 'block';
            });
        }
        
        // Initialize pagination when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Set initial display for review cards
            const reviewCards = document.querySelectorAll('.review-card');
            reviewCards.forEach(card => {
                const initialDisplay = card.getAttribute('data-initial-display');
                if (initialDisplay) {
                    card.style.display = initialDisplay;
                }
            });
            
            // Initialize with all reviews and pagination
            filteredReviews = Array.from(reviewCards);
            updateVisibleCount();
            showCurrentPageReviews();
            updatePagination();
        });
        
        // Chatbot functionality
        function toggleChatbot() {
            const modal = document.getElementById('chatbot-modal');
            if (modal.style.display === 'flex') {
                modal.style.display = 'none';
            } else {
                modal.style.display = 'flex';
                document.getElementById('chatbot-input').focus();
            }
        }
        
        function handleChatbotKeypress(event) {
            if (event.key === 'Enter') {
                sendChatbotMessage();
            }
        }
        
        function sendChatbotMessage() {
            const input = document.getElementById('chatbot-input');
            const message = input.value.trim();
            
            if (!message) return;
            
            // Add user message to chat
            addMessage(message, 'user');
            input.value = '';
            
            // Send to backend
            fetch('/chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    message: message,
                    reviews: JSON.parse('{{ reviews|tojson|safe }}')
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.reply === '__chart__') {
                    // Handle chart response
                    addMessage(`Chart: ${data.chart_type}`, 'bot');
                } else {
                    // Handle text response
                    addMessage(data.reply, 'bot');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                addMessage('Sorry, I encountered an error. Please try again.', 'bot');
            });
        }
        
        function addMessage(content, sender) {
            const messagesContainer = document.getElementById('chatbot-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}-message`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.innerHTML = content.replace(/\n/g, '<br>');
            
            messageDiv.appendChild(contentDiv);
            messagesContainer.appendChild(messageDiv);
            
            // Scroll to bottom
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
    </script>
    
    <!-- Client-side fallback for missing counts -->
    <script>
        // Reviews from server; default to empty array
        window.allReviews = {{ reviews | default([]) | tojson }};

        function computeCounts(reviews) {
            const norm = s => String(s ?? '').trim().toLowerCase();
            let pos=0, neu=0, neg=0, pack=0;
            for (const r of reviews) {
                const sent = norm(r.sentiment);
                if (sent.startsWith('pos')) pos++;
                else if (sent.startsWith('neu')) neu++;
                else if (sent.startsWith('neg')) neg++;
                const pr = r.is_packaging_related;
                if (pr === true || norm(pr)==='true' || pr === 1) pack++;
            }
            const packaging_pct = reviews.length > 0 ? Math.round((pack / reviews.length * 100) * 10) / 10 : 0;
            return { total: reviews.length, positive: pos, neutral: neu, negative: neg, packaging_related: pack, packaging_pct: packaging_pct };
        }

        function setText(id, val) {
            const el = document.getElementById(id);
            if (el) el.textContent = String(val);
        }

        document.addEventListener('DOMContentLoaded', () => {
            const c = computeCounts(window.allReviews || []);

            // KPIs
            setText('kpi-total', c.total);
            setText('kpi-pack', c.packaging_related);
            setText('kpi-positive', c.positive);
            setText('kpi-neutral', c.neutral);
            setText('kpi-negative', c.negative);
            // keep server defects if present; if missing, leave as-is
            if (!document.getElementById('kpi-defects')?.textContent?.trim()) {
                setText('kpi-defects', 0);
            }

            // Filter badges
            setText('count-all', c.total);
            setText('count-pack', c.packaging_related);
            setText('count-pos', c.positive);
            setText('count-neu', c.neutral);
            setText('count-neg', c.negative);
        });
    </script>

</body>
</html> 